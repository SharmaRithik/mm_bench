<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Matrix Multiplication Benchmark</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/1.2.1/chartjs-plugin-zoom.min.js"></script>
    <style>
        body, html {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: #f0f0f0;
        }
        .top-bar {
            background-color: #007bff;
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }
        .container {
            padding: 20px;
            height: calc(100% - 100px);
            box-sizing: border-box;
        }
        .row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .tile {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin: 0 10px;
        }
        .tile-header {
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            color: #333;
        }
        .checkbox-group { margin: 10px 0; }
        .checkbox-group label { margin-right: 10px; }
        #results {
            margin-top: 20px;
            height: 300px;
        }
        canvas { max-width: 100%; }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            margin-right: 10px;
        }
        button.reset {
            background-color: #dc3545;
        }
        #deviceInfo { font-size: 14px; line-height: 1.6; }
        
        .device-info-tile { flex: 0 0 35%; }
        .matrix-sizes-tile { flex: 0 0 30%; }
        .benchmark-tile { flex: 0 0 25%; }
        .operation-type-tile { flex: 0 0 20%; }
        .multiplication-methods-tile { flex: 0 0 45%; }
        .tuning-tile { flex: 0 0 30%; }
        
        .matrix-sizes-group {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }
        .matrix-sizes-group label {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .matrix-sizes-group input[type="checkbox"] {
            margin-right: 5px;
        }
        .tuning-params {
            display: flex;
            flex-direction: column;
        }
        .tuning-param {
            margin-bottom: 10px;
        }
        .workgroup-size-options, .tile-size-options {
            display: flex;
            gap: 10px;
        }
        .workgroup-size-option, .tile-size-option {
            display: flex;
            align-items: center;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .results-tile {
            flex: 0 0 100%;
        }
        .graph-tile {
            flex: 0 0 100%;
            display: flex;
            flex-direction: column;
        }
        .chart-container {
            width: 80%;
            height: 400px;
            margin: 0 auto;
        }
        #benchmarkChart {
            max-width: 100%;
            height: auto;
        }
        #generateButton {
            background-color: yellow;
            color: black;
        }
        #generateButton.generated {
            background-color: green;
            color: white;
        }
	@media (max-width: 768px) {
        .container {
            padding: 10px;
        }
        .row {
            flex-direction: column;
        }
        .tile {
            margin: 10px 0;
            width: 100%;
        }
        .matrix-sizes-group {
            grid-template-columns: repeat(3, 1fr);
        }
        #benchmarkChart {
            height: 300px;
        }
	        .summary-tile {
            flex: 0 0 100%;
        }
        #bestMethodsTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        #bestMethodsTable th, #bestMethodsTable td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        #bestMethodsTable th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        #bestMethodsTable tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        #bestMethodsTable tr:hover {
            background-color: #f5f5f5;
        }
    }
    </style>
</head>
<body>
    <div class="top-bar">
        How much PERF/GFLOPS can you achieve?
    </div>
    <div class="container">
	<div id="unsupportedMessage" style="display: none; color: red; font-weight: bold;"></div>
        <div id="benchmarkControls">
            <div class="row">
                <div class="tile device-info-tile">
                    <div class="tile-header">Device Information</div>
                    <div id="deviceInfo">Loading...</div>
                </div>
                <div class="tile matrix-sizes-tile">
                    <div class="tile-header">Matrix Sizes</div>
                    <div class="matrix-sizes-group">
                        <label><input type="checkbox" class="size-checkbox" id="size8" value="8" checked>8</label>
                        <label><input type="checkbox" class="size-checkbox" id="size16" value="16" checked>16</label>
                        <label><input type="checkbox" class="size-checkbox" id="size32" value="32" checked>32</label>
                        <label><input type="checkbox" class="size-checkbox" id="size64" value="64" checked>64</label>
                        <label><input type="checkbox" class="size-checkbox" id="size128" value="128" checked>128</label>
                        <label><input type="checkbox" class="size-checkbox" id="size256" value="256" checked>256</label>
                        <label><input type="checkbox" class="size-checkbox" id="size512" value="512" checked>512</label>
                        <label><input type="checkbox" class="size-checkbox" id="size1024" value="1024" checked>1024</label>
                        <label><input type="checkbox" class="size-checkbox" id="size2048" value="2048" checked>2048</label>
                        <label><input type="checkbox" class="size-checkbox" id="size4096" value="4096" checked>4096</label>
                    </div>
                    <div style="margin-top: 10px;">
                        <button id="selectSizes">Select Size</button>
                        <button id="selectAllSizes">Select All</button>
                        <button id="resetSizes" class="reset">Reset</button>
                        <button id="generateButton">Generating</button>
                    </div>
                </div>
                <div class="tile benchmark-tile">
                    <div class="tile-header">Benchmark</div>
                    <div>
                        <label for="iterationNumber">Iteration number:</label>
                        <input type="number" id="iterationNumber" value="16" min="1" max="100">
                    </div>
                    <div style="margin-top: 10px;">
                        <button id="runBenchmark">Run Benchmark</button>
                        <button id="resetBenchmark" class="reset">Reset</button>
                        <button id="downloadResults">Download Results</button>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="tile operation-type-tile">
                    <div class="tile-header">Operation Type</div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="gemm" value="gemm" checked><label for="gemm">GEMM</label>
                        <input type="checkbox" id="gemv" value="gemv"><label for="gemv">GEMV</label>
                    </div>
                </div>
                <div class="tile multiplication-methods-tile">
                    <div class="tile-header">Multiplication Methods</div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="naive" value="naive" checked><label for="naive">Naive</label>
                        <input type="checkbox" id="gmemCoalescing" value="gmemCoalescing" checked><label for="gmemCoalescing">GMEM Coalescing</label>
                        <input type="checkbox" id="smemCaching" value="smemCaching" checked><label for="smemCaching">SMEM Caching</label>
			<input type="checkbox" id="tiledDotProduct" value="tiledDotProduct" checked><label for="tiledDotProduct">Tiled Dot Product</label>
			<input type="checkbox" id="vectorized" value="vectorized" checked><label for="vectorized">Vectorized</label>
			<input type="checkbox" id="vectorized8ins" value="vectorized8ins" checked><label for="vectorized8ins">Vectorized (8 ins)</label>
			<input type="checkbox" id="vectorized16ins" value="vectorized16ins" checked><label for="vectorized16ins">Vectorized (16 ins)</label>
                        <input type="checkbox" id="sharedMemoryVectorizedTile4" value="sharedMemoryVectorizedTile4" checked><label for="sharedMemoryVectorizedTile4">Shared Memory Vectorized (Tile 4x4)</label>
                        <input type="checkbox" id="sharedMemoryVectorizedTile8" value="sharedMemoryVectorizedTile8" checked><label for="sharedMemoryVectorizedTile8">Shared Memory Vectorized (Tile 8x8)</label>
                        <input type="checkbox" id="sharedMemoryVectorizedTile16" value="sharedMemoryVectorizedTile16" checked><label for="sharedMemoryVectorizedTile16">Shared Memory Vectorized (Tile 16x16)</label>
                        <input type="checkbox" id="sharedMemoryVectorizedTile32" value="sharedMemoryVectorizedTile32"><label for="sharedMemoryVectorizedTile32">Shared Memory Vectorized (Tile 32x32)</label>
			<input type="checkbox" id="Global2dTiling8" value="Global2dTiling8" checked><label for="Global2dTiling8">Global 2D Tiling 8x8</label>
			<input type="checkbox" id="Shared2dTiling8" value="Shared2dTiling8" checked><label for="Shared2dTiling8">Shared 2D Tiling 8x8</label>
                        <input type="checkbox" id="Global2dTiling16" value="Global2dTiling16" checked><label for="Global2dTiling16">Global 2D Tiling 16x16</label>
                        <input type="checkbox" id="Shared2dTiling16" value="Shared2dTiling16" checked><label for="Shared2dTiling16">Shared 2D Tiling 16x16</label>
		        <input type="checkbox" id="Global1dTiling8" value="Global1dTiling8" checked><label for="Global1dTiling8">Global 1D Tiling 8</label>
                        <input type="checkbox" id="Shared1dTiling8" value="Shared1dTiling8"><label for="Shared1dTiling8">Shared 1D Tiling 8</label>
                        <input type="checkbox" id="Global1dTiling16" value="Global1dTiling16" checked><label for="Global1dTiling16">Global 1D Tiling 16</label>
                        <input type="checkbox" id="Shared1dTiling16" value="Shared1dTiling16"><label for="Shared1dTiling16">Shared 1D Tiling 16</label>
			<input type="checkbox" id="sharedMemoryVectorizedTileBatched" value="sharedMemoryVectorizedTileBatched"><label for="sharedMemoryVectorizedTileBatched">Shared Memory Vectorized Tile Batched</label>
			<input type="checkbox" id="DecoupledAxis2x128" value="DecoupledAxis2x128" checked><label for="DecoupledAxis2x128">Decoupled Axis (2x128)</label>
			<input type="checkbox" id="DecoupledAxis4x64" value="DecoupledAxis4x64" checked><label for="DecoupledAxis4x64">Decoupled Axis (4x64)</label>
			<input type="checkbox" id="DecoupledAxis8x32" value="DecoupledAxis8x32" checked><label for="DecoupledAxis8x32">Decoupled Axis (8x32)</label>
			<input type="checkbox" id="DecoupledAxis16x16" value="DecoupledAxis16x16" checked><label for="DecoupledAxis16x16">Decoupled Axis (16x16)</label>
			<input type="checkbox" id="DecoupledAxis32x8" value="DecoupledAxis32x8" checked><label for="DecoupledAxis32x8">Decoupled Axis (32x8)</label>
			<input type="checkbox" id="DecoupledAxis64x4" value="DecoupledAxis64x4" checked><label for="DecoupledAxis64x4">Decoupled Axis (64x4)</label>
			<input type="checkbox" id="DecoupledAxis128x2" value="DecoupledAxis128x2" checked><label for="DecoupledAxis128x2">Decoupled Axis (128x2)</label>
                    </div>
                    <div style="margin-top: 10px;">
                        <button id="selectAllMethods">Select All</button>
                        <button id="resetMethods" class="reset">Reset</button>
                    </div>
                </div>
                <div class="tile tuning-tile">
                    <div class="tile-header">Tuning Parameters</div>
                    <div class="workgroup-sizes">
                        <h4>Workgroup Sizes</h4>
                        <div class="workgroup-size-options">
                            <div class="workgroup-size-option">
                                <input type="checkbox" id="workgroup4x4" name="workgroupSize" value="4,4">
                                <label for="workgroup4x4">4x4</label>
                            </div>
                            <div class="workgroup-size-option">
                                <input type="checkbox" id="workgroup8x8" name="workgroupSize" value="8,8">
                                <label for="workgroup8x8">8x8</label>
                            </div>
                            <div class="workgroup-size-option">
                                <input type="checkbox" id="workgroup16x16" name="workgroupSize" value="16,16" checked>
                                <label for="workgroup16x16">16x16</label>
                            </div>
                        </div>
                    </div>
                    <div class="tile-sizes">
                        <h4>Tile Sizes (GMEM Coalescing only)</h4>
                        <div class="tile-size-options">
                            <div class="tile-size-option">
                                <input type="checkbox" id="tileSize4" name="tileSize" value="4">
                                <label for="tileSize4">4x4</label>
                            </div>
                            <div class="tile-size-option">
                                <input type="checkbox" id="tileSize8" name="tileSize" value="8">
                                <label for="tileSize8">8x8</label>
                            </div>
                            <div class="tile-size-option">
                                <input type="checkbox" id="tileSize16" name="tileSize" value="16" checked>
                                <label for="tileSize16">16x16</label>
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 10px;">
                        <button id="selectAllTuningMethods">Select All Tuning Methods</button>
                    </div>
                </div>
            </div>
            <div class="row">
                <div class="tile results-tile">
                    <div class="tile-header">Results</div>
                    <div id="resultsTables"></div>
                </div>
            </div>
            <div class="row">
                <div class="tile graph-tile">
                    <div class="tile-header">Graph</div>
                    <div class="chart-container">
                        <canvas id="benchmarkChart"></canvas>
                    </div>
                </div>
            </div>
	        <div class="row">
                <div class="tile summary-tile">
                    <div class="tile-header">Best Methods Summary</div>
                    <table id="bestMethodsTable">
                        <thead>
                            <tr>
                                <th>Matrix Size</th>
                                <th>Best Method</th>
                                <th>Time (ms)</th>
                                <th>GFLOPS</th>
                                <th>Tuning Parameters</th>
                            </tr>
                        </thead>
                        <tbody>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    <script type="module">
        let device;

        async function initializeWebGPU() {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }
            device = await adapter.requestDevice();
            return device;
        }

        function createBuffer(data, usage) {
            const buffer = device.createBuffer({
                size: data.byteLength,
                usage: usage,
                mappedAtCreation: true,
            });
            new Float32Array(buffer.getMappedRange()).set(data);
            buffer.unmap();
            return buffer;
        }

        let generatedMatrices = {};

        async function generateMatrices(sizes) {
            const generateButton = document.getElementById("generateButton");
            generateButton.textContent = "Generating";
            generateButton.style.backgroundColor = "yellow";
            generateButton.style.color = "black";

            for (const N of sizes) {
                const matrixSize = N * N;
                const matrixA = new Float32Array(matrixSize);
                const matrixB = new Float32Array(matrixSize);
	        const matrixAVec4 = new Float32Array(matrixSize);
                const matrixBVec4 = new Float32Array(matrixSize);

	    // Initialize matrices with random values
            for (let i = 0; i < matrixSize; i++) {
                const value = Math.random();
                matrixA[i] = value;
                matrixB[i] = value;
                matrixAVec4[i] = value;
                matrixBVec4[i] = value;
            }
                const bufferA = createBuffer(matrixA, GPUBufferUsage.STORAGE);
                const bufferB = createBuffer(matrixB, GPUBufferUsage.STORAGE);
	        const bufferAVec4 = createBuffer(matrixAVec4, GPUBufferUsage.STORAGE);
                const bufferBVec4 = createBuffer(matrixBVec4, GPUBufferUsage.STORAGE);

                generatedMatrices[N] = { bufferA, bufferB, bufferAVec4, bufferBVec4, matrixA, matrixB };
            }

            generateButton.textContent = "Generated";
            generateButton.style.backgroundColor = "green";
            generateButton.style.color = "white";
        }

        function updateBestMethodsSummary(results) {
            const bestMethodsTable = document.getElementById("bestMethodsTable").getElementsByTagName('tbody')[0];
            bestMethodsTable.innerHTML = ''; // Clear existing rows
    
            // Get all unique matrix sizes
            const matrixSizes = [...new Set(Object.values(results)
                .flatMap(implementationResults => implementationResults
                    .map(result => result.size)))].sort((a, b) => a - b);
    
            matrixSizes.forEach(size => {
                // Find the best result for this size across all implementations
                let bestResult = {
                    time: Infinity,
                    implementation: '',
                    gflops: 0,
                    tuningParameters: ''
                };
    
                Object.entries(results).forEach(([implementation, implementationResults]) => {
                    const result = implementationResults.find(r => r.size === size);
                    if (result && result.time < bestResult.time) {
                        bestResult = {
                            time: result.time,
                            implementation: implementation.split('-')[0], // Get base implementation name
                            gflops: result.gflops,
                            tuningParameters: result.tuningParameters
                        };
                    }
                });
    
                // Only add row if we found results for this size
                if (bestResult.time !== Infinity) {
                    const row = bestMethodsTable.insertRow();
                    row.innerHTML = `
                        <td>${size}x${size}</td>
                        <td>${bestResult.implementation}</td>
                        <td>${bestResult.time.toFixed(2)}</td>
                        <td>${bestResult.gflops.toFixed(2)}</td>
                        <td>${bestResult.tuningParameters}</td>
                    `;
                }
            });
        }

        function getNaiveWGSL(workgroupSize) {
            const [x, y] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;

                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }

                @compute @workgroup_size(${x}, ${y})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                    let row = global_id.y;
                    let col = global_id.x;
                    if (row < uniforms.N && col < uniforms.N) {
                        var sum = 0.0;
                        for (var i = 0u; i < uniforms.N; i = i + 1u) {
                            sum = sum + matrixA[row * uniforms.N + i] * matrixB[i * uniforms.N + col];
                        }
			matrixC[row * uniforms.N + col] = uniforms.alpha * sum + uniforms.beta * matrixC[row * uniforms.N + col];
                    }
                }
            `;
        }

        function getGMEMCoalescingWGSL(workgroupSize, tileSize) {
            const [x, y] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;
                
                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }
                const TILE_SIZE : u32 = ${tileSize}u;
                @compute @workgroup_size(${x}, ${y})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                    let row = global_id.y;
                    let col = global_id.x;
                    let N = uniforms.N;
                    // Out of bounds check
                    if (row >= N || col >= N) {
                        return;
                    }
                    var sum = 0.0;
                    // Loop over tiles of size TILE_SIZE
                    for (var t = 0u; t < N; t += TILE_SIZE) {
                        // Process TILE_SIZE elements from matrixA and matrixB
                        for (var i = 0u; i < TILE_SIZE; i++) {
                            let k = t + i;
                            if (k < N) {
                                // Coalesced read from matrixA (row-major)
                                let aElement = matrixA[row * N + k];
                                // Coalesced read from matrixB (column-major)
                                let bElement = matrixB[k * N + col];
                                sum += aElement * bElement;
                            }
                        }
                    }
                    // Write the result back to matrixC with scaling
                    let index = row * N + col;
                    matrixC[index] = uniforms.alpha * sum + uniforms.beta * matrixC[index];
                }
            `;
        }

        function getSMEMCacheBlockingWGSL(workgroupSize, tileSize) {
            const [x, y] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;

                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }

                const TILE_SIZE : u32 = ${tileSize}u;

                var<workgroup> tileA : array<array<f32, ${tileSize}>, ${tileSize}>;
                var<workgroup> tileB : array<array<f32, ${tileSize}>, ${tileSize}>;

                @compute @workgroup_size(${x}, ${y})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>, @builtin(local_invocation_id) local_id : vec3<u32>) {
                    let row = global_id.y;
                    let col = global_id.x;
                    let tileRow = local_id.y;
                    let tileCol = local_id.x;

                    var sum = 0.0;

                    for (var t = 0u; t < uniforms.N; t += TILE_SIZE) {
                        // Collaborative loading of tiles into shared memory
                        if (t + tileCol < uniforms.N && row < uniforms.N) {
                            tileA[tileRow][tileCol] = matrixA[row * uniforms.N + (t + tileCol)];
                        }
                        if (t + tileRow < uniforms.N && col < uniforms.N) {
                            tileB[tileRow][tileCol] = matrixB[(t + tileRow) * uniforms.N + col];
                        }

                        workgroupBarrier();

                        // Compute using tiles
                        for (var k = 0u; k < TILE_SIZE; k++) {
                            if (t + k < uniforms.N) {
                                sum += tileA[tileRow][k] * tileB[k][tileCol];
                            }
                        }

                        workgroupBarrier();
                    }

                    if (row < uniforms.N && col < uniforms.N) {
                        let index = row * uniforms.N + col;
                        matrixC[index] = uniforms.alpha * sum + uniforms.beta * matrixC[index];
                    }
                }
            `;
        }

        function getTiledDotProductWGSL(workgroupSize) {
            const [x, y] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;
                
                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }
        
                const TILE_SIZE = ${x}u;  // Match tile size to workgroup size
                const VECTOR_SIZE = 4u;
        
                var<workgroup> tileA: array<array<f32, ${x}>, ${x}>;
                var<workgroup> tileB: array<array<f32, ${x}>, ${x}>;
        
                fn load_tile(global_row: u32, global_col: u32, N: u32, isA: bool) -> f32 {
                    if (isA) {
                        if (global_row < N && global_col < N) {
                            return matrixA[global_row * N + global_col];
                        }
                    } else {
                        if (global_row < N && global_col < N) {
                            return matrixB[global_row * N + global_col];
                        }
                    }
                    return 0.0;
                }
        
                @compute @workgroup_size(${x}, ${y})
                fn main(
                    @builtin(global_invocation_id) global_id: vec3<u32>,
                    @builtin(local_invocation_id) local_id: vec3<u32>,
                    @builtin(workgroup_id) group_id: vec3<u32>
                ) {
                    let N = uniforms.N;
        
                    let row = global_id.y;
                    let col = global_id.x;
                    let lid_row = local_id.y;
                    let lid_col = local_id.x;
        
                    var acc = 0.0;
        
                    // Process matrix in tiles
                    for (var t = 0u; t < N; t += TILE_SIZE) {
                        // Load tiles collaboratively
                        let tileA_row = row;
                        let tileA_col = t + lid_col;
                        let tileB_row = t + lid_row;
                        let tileB_col = col;
        
                        tileA[lid_row][lid_col] = load_tile(tileA_row, tileA_col, N, true);
                        tileB[lid_row][lid_col] = load_tile(tileB_row, tileB_col, N, false);
        
                        workgroupBarrier();
        
                        // Compute dot product for this tile
                        for (var k = 0u; k < TILE_SIZE; k++) {
                            acc += tileA[lid_row][k] * tileB[k][lid_col];
                        }
        
                        workgroupBarrier();
                    }
        
                    // Write result
                    if (row < N && col < N) {
                        let idx = row * N + col;
                        matrixC[idx] = uniforms.alpha * acc + uniforms.beta * matrixC[idx];
                    }
                }
            `;
        }

        function getVectorizedWGSL(workgroupSize) {
            const [x, y] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;
                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }
        
                @compute @workgroup_size(${x}, ${y})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                    let row = global_id.y;
                    let col = global_id.x;
                    if (row < uniforms.N && col < uniforms.N) {
                        var sum = 0.0;
                        for (var i = 0u; i < uniforms.N; i += 4u) {
                            let aVec = vec4<f32>(
                                matrixA[row * uniforms.N + i],
                                matrixA[row * uniforms.N + i + 1],
                                matrixA[row * uniforms.N + i + 2],
                                matrixA[row * uniforms.N + i + 3]
                            );
                            let bVec = vec4<f32>(
                                matrixB[i * uniforms.N + col],
                                matrixB[(i + 1) * uniforms.N + col],
                                matrixB[(i + 2) * uniforms.N + col],
                                matrixB[(i + 3) * uniforms.N + col]
                            );
                            sum += dot(aVec, bVec);
                        }
                        matrixC[row * uniforms.N + col] = uniforms.alpha * sum + uniforms.beta * matrixC[row * uniforms.N + col];
                    }
                }
            `;
        }

        function getVectorized8insWGSL(workgroupSize) {
            const [x, y] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;
                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }
        
                @compute @workgroup_size(${x}, ${y})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                    let row = global_id.y;
                    let col = global_id.x;
                    if (row < uniforms.N && col < uniforms.N) {
                        var sum = 0.0;
                        // Process 8 elements at a time
                        for (var i = 0u; i < uniforms.N; i += 8u) {
                            // Load 8 elements from matrix A
                            let aVec1 = vec4<f32>(
                                matrixA[row * uniforms.N + i],
                                matrixA[row * uniforms.N + i + 1],
                                matrixA[row * uniforms.N + i + 2],
                                matrixA[row * uniforms.N + i + 3]
                            );
                            let aVec2 = vec4<f32>(
                                matrixA[row * uniforms.N + i + 4],
                                matrixA[row * uniforms.N + i + 5],
                                matrixA[row * uniforms.N + i + 6],
                                matrixA[row * uniforms.N + i + 7]
                            );
                            
                            // Load 8 elements from matrix B
                            let bVec1 = vec4<f32>(
                                matrixB[i * uniforms.N + col],
                                matrixB[(i + 1) * uniforms.N + col],
                                matrixB[(i + 2) * uniforms.N + col],
                                matrixB[(i + 3) * uniforms.N + col]
                            );
                            let bVec2 = vec4<f32>(
                                matrixB[(i + 4) * uniforms.N + col],
                                matrixB[(i + 5) * uniforms.N + col],
                                matrixB[(i + 6) * uniforms.N + col],
                                matrixB[(i + 7) * uniforms.N + col]
                            );
                            
                            // Compute dot products and add them
                            sum += dot(aVec1, bVec1) + dot(aVec2, bVec2);
                        }
                        matrixC[row * uniforms.N + col] = uniforms.alpha * sum + uniforms.beta * matrixC[row * uniforms.N + col];
                    }
                }
            `;
        }
        
        function getVectorized16insWGSL(workgroupSize) {
            const [x, y] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;
                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }
        
                @compute @workgroup_size(${x}, ${y})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                    let row = global_id.y;
                    let col = global_id.x;
                    if (row < uniforms.N && col < uniforms.N) {
                        var sum = 0.0;
                        // Process 16 elements at a time
                        for (var i = 0u; i < uniforms.N; i += 16u) {
                            // Load 16 elements from matrix A using 4 vec4s
                            let aVec1 = vec4<f32>(
                                matrixA[row * uniforms.N + i],
                                matrixA[row * uniforms.N + i + 1],
                                matrixA[row * uniforms.N + i + 2],
                                matrixA[row * uniforms.N + i + 3]
                            );
                            let aVec2 = vec4<f32>(
                                matrixA[row * uniforms.N + i + 4],
                                matrixA[row * uniforms.N + i + 5],
                                matrixA[row * uniforms.N + i + 6],
                                matrixA[row * uniforms.N + i + 7]
                            );
                            let aVec3 = vec4<f32>(
                                matrixA[row * uniforms.N + i + 8],
                                matrixA[row * uniforms.N + i + 9],
                                matrixA[row * uniforms.N + i + 10],
                                matrixA[row * uniforms.N + i + 11]
                            );
                            let aVec4 = vec4<f32>(
                                matrixA[row * uniforms.N + i + 12],
                                matrixA[row * uniforms.N + i + 13],
                                matrixA[row * uniforms.N + i + 14],
                                matrixA[row * uniforms.N + i + 15]
                            );
        
                            // Load 16 elements from matrix B using 4 vec4s
                            let bVec1 = vec4<f32>(
                                matrixB[i * uniforms.N + col],
                                matrixB[(i + 1) * uniforms.N + col],
                                matrixB[(i + 2) * uniforms.N + col],
                                matrixB[(i + 3) * uniforms.N + col]
                            );
                            let bVec2 = vec4<f32>(
                                matrixB[(i + 4) * uniforms.N + col],
                                matrixB[(i + 5) * uniforms.N + col],
                                matrixB[(i + 6) * uniforms.N + col],
                                matrixB[(i + 7) * uniforms.N + col]
                            );
                            let bVec3 = vec4<f32>(
                                matrixB[(i + 8) * uniforms.N + col],
                                matrixB[(i + 9) * uniforms.N + col],
                                matrixB[(i + 10) * uniforms.N + col],
                                matrixB[(i + 11) * uniforms.N + col]
                            );
                            let bVec4 = vec4<f32>(
                                matrixB[(i + 12) * uniforms.N + col],
                                matrixB[(i + 13) * uniforms.N + col],
                                matrixB[(i + 14) * uniforms.N + col],
                                matrixB[(i + 15) * uniforms.N + col]
                            );
        
                            // Compute dot products and add them
                            sum += dot(aVec1, bVec1) + dot(aVec2, bVec2) +
                                  dot(aVec3, bVec3) + dot(aVec4, bVec4);
                        }
                        matrixC[row * uniforms.N + col] = uniforms.alpha * sum + uniforms.beta * matrixC[row * uniforms.N + col];
                    }
                }
            `;
        }
	function getSharedMemoryVectorizedWGSL(tileSize, workgroupSize) {
            const [x, y] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;
        
                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }
        
                const TILE_SIZE = ${tileSize}u;
                var<workgroup> tileA : array<array<f32, TILE_SIZE>, TILE_SIZE>;
                var<workgroup> tileB : array<array<f32, TILE_SIZE>, TILE_SIZE>;
        
                @compute @workgroup_size(${x}, ${y})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>, @builtin(local_invocation_id) local_id : vec3<u32>) {
                    let row = global_id.y;
                    let col = global_id.x;
                    let localRow = local_id.y;
                    let localCol = local_id.x;
        
                    var sum : vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        
                    for (var t = 0u; t < uniforms.N; t += TILE_SIZE) {
                        // Collaborative loading of tiles into shared memory
                        if (t + localCol < uniforms.N && row < uniforms.N) {
                            tileA[localRow][localCol] = matrixA[row * uniforms.N + (t + localCol)];
                        }
                        if (t + localRow < uniforms.N && col < uniforms.N) {
                            tileB[localRow][localCol] = matrixB[(t + localRow) * uniforms.N + col];
                        }
        
                        workgroupBarrier();
        
                        // Compute using tiles
                        for (var k = 0u; k < TILE_SIZE; k += 4u) {
                            let aVec = vec4<f32>(
                                tileA[localRow][k],
                                tileA[localRow][k + 1u],
                                tileA[localRow][k + 2u],
                                tileA[localRow][k + 3u]
                            );
                            let bVec = vec4<f32>(
                                tileB[k][localCol],
                                tileB[k + 1u][localCol],
                                tileB[k + 2u][localCol],
                                tileB[k + 3u][localCol]
                            );
                            sum += aVec * bVec;
                        }
        
                        workgroupBarrier();
                    }
        
                    if (row < uniforms.N && col < uniforms.N) {
                        let totalSum = sum.x + sum.y + sum.z + sum.w;
                        matrixC[row * uniforms.N + col] = uniforms.alpha * totalSum + uniforms.beta * matrixC[row * uniforms.N + col];
                    }
                }
            `;
        }

        function getTiledWGSL(workgroupSize, tileSize, useSharedMemory) {
            const [x, y] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;
        
                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }
        
                ${useSharedMemory ? `
                // Shared memory for tiles (shared across the workgroup)
                var<workgroup> tileA : array<array<f32, ${tileSize}>, ${tileSize}>;
                var<workgroup> tileB : array<array<f32, ${tileSize}>, ${tileSize}>;
                ` : ''}
        
                @compute @workgroup_size(${x}, ${y})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>, @builtin(local_invocation_id) local_id : vec3<u32>) {
                    let row = global_id.y;
                    let col = global_id.x;
                    let N = uniforms.N;
        
                    var acc = 0.0;
                    let numTiles = (N + ${tileSize}u - 1u) / ${tileSize}u;
        
                    // Check row and column bounds only once
                    let validRow = row < N;
                    let validCol = col < N;
        
                    ${useSharedMemory ? `
                    // Loop over the number of tiles
                    for (var t = 0u; t < numTiles; t = t + 1u) {
                        // Load tileA from matrixA into shared memory only if row is valid
                        if (validRow && (t * ${tileSize}u + local_id.x) < N) {
                            tileA[local_id.y][local_id.x] = matrixA[row * N + t * ${tileSize}u + local_id.x];
                        } else {
                            tileA[local_id.y][local_id.x] = 0.0;
                        }
        
                        // Load tileB from matrixB into shared memory only if col is valid
                        if (validCol && (t * ${tileSize}u + local_id.y) < N) {
                            tileB[local_id.y][local_id.x] = matrixB[(t * ${tileSize}u + local_id.y) * N + col];
                        } else {
                            tileB[local_id.y][local_id.x] = 0.0;
                        }
        
                        // Synchronize to ensure all threads have loaded their tile data
                        workgroupBarrier();
        
                        // Multiply the two tiles and accumulate the result
                        for (var k = 0u; k < ${tileSize}u; k = k + 1u) {
                            acc = acc + tileA[local_id.y][k] * tileB[k][local_id.x];
                        }
        
                        // Synchronize before loading the next tile
                        workgroupBarrier();
                    }
                    ` : `
                    // Perform tiling without using shared memory
                    if (validRow && validCol) {
                        for (var t = 0u; t < numTiles; t = t + 1u) {
                            for (var k = 0u; k < ${tileSize}u; k = k + 1u) {
                                let aIndex = row * N + (t * ${tileSize}u + k);
                                let bIndex = (t * ${tileSize}u + k) * N + col;
        
                                if (aIndex < N * N && bIndex < N * N) {
                                    acc = acc + matrixA[aIndex] * matrixB[bIndex];
                                }
                            }
                        }
                    }
                    `}
        
                    // Write the result to matrixC only if row and col are valid
                    if (validRow && validCol) {
                        matrixC[row * N + col] = uniforms.alpha * acc + uniforms.beta * matrixC[row * N + col];
                    }
                }
            `;
        }

        function get1dTiledWGSL(workgroupSize, tileSize, useSharedMemory) {
            if (!useSharedMemory) {
                return `
                    @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                    @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                    @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                    @group(0) @binding(3) var<uniform> uniforms : Uniforms;
        
                    struct Uniforms {
                        N : u32,
                        alpha : f32,
                        beta : f32,
                        chunkOffset : u32,
                    }
        
                    const TILE_SIZE = ${tileSize}u;
                    const CHUNK_SIZE = ${workgroupSize}u;
        
                    @compute @workgroup_size(${workgroupSize})
                    fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                        let N = uniforms.N;
                        let baseIndex = uniforms.chunkOffset * CHUNK_SIZE + global_id.x;
        
                        let row = baseIndex / N;
                        let col = baseIndex % N;
        
                        if (row >= N || col >= N) {
                            return;
                        }
        
                        var sum = 0.0;
                        let rowOffset = row * N;
        
                        for (var k = 0u; k < N; k += TILE_SIZE) {
                            let tileEnd = min(k + TILE_SIZE, N);
        
                            for (var tk = k; tk < tileEnd; tk++) {
                                sum += matrixA[rowOffset + tk] * matrixB[tk * N + col];
                            }
                        }
        
                        let outIndex = rowOffset + col;
                        matrixC[outIndex] = uniforms.alpha * sum + uniforms.beta * matrixC[outIndex];
                    }
                `;
            }
        
            // Shared memory version
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;
        
                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                    chunkOffset : u32,
                }
        
                const TILE_SIZE = ${tileSize}u;
                const CHUNK_SIZE = ${workgroupSize}u;
        
                var<workgroup> tileA: array<f32, TILE_SIZE * CHUNK_SIZE>;
                var<workgroup> tileB: array<f32, TILE_SIZE * CHUNK_SIZE>;
        
                @compute @workgroup_size(${workgroupSize})
                fn main(
                    @builtin(global_invocation_id) global_id : vec3<u32>,
                    @builtin(local_invocation_id) local_id : vec3<u32>
                ) {
                    let N = uniforms.N;
                    let baseIndex = uniforms.chunkOffset * CHUNK_SIZE + local_id.x;
        
                    let row = baseIndex / N;
                    let col = baseIndex % N;
        
                    if (row >= N || col >= N) {
                        return;
                    }
        
                    var sum = 0.0;
                    let rowOffset = row * N;
        
                    for (var k = 0u; k < N; k += TILE_SIZE) {
                        if (k + local_id.x < N) {
                            let aIndex = rowOffset + k + local_id.x;
                            let bIndex = (k + local_id.x) * N + col;
        
                            tileA[local_id.x] = matrixA[aIndex];
                            tileB[local_id.x] = matrixB[bIndex];
                        } else {
                            tileA[local_id.x] = 0.0;
                            tileB[local_id.x] = 0.0;
                        }
        
                        workgroupBarrier();
        
                        for (var tk = 0u; tk < TILE_SIZE; tk++) {
                            if (k + tk < N) {
                                sum += tileA[tk] * tileB[tk];
                            }
                        }
        
                        workgroupBarrier();
                    }
        
                    let outIndex = rowOffset + col;
                    matrixC[outIndex] = uniforms.alpha * sum + uniforms.beta * matrixC[outIndex];
                }
            `;
        }

        function getSharedMemoryVectorizedTileBatchedWGSL(tileSize, workgroupSize, batchSize) {
            const [x, y] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;
        
                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }
        
                const TILE_SIZE = ${tileSize}u;
                const BATCH_SIZE = ${batchSize}u;
                var<workgroup> tileA : array<array<vec4<f32>, ${tileSize / 4}>, ${tileSize}>;
                var<workgroup> tileB : array<array<vec4<f32>, ${tileSize / 4}>, ${tileSize}>;
        
                @compute @workgroup_size(${x}, ${y})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>, @builtin(local_invocation_id) local_id : vec3<u32>) {
                    let row = global_id.y;
                    let col = global_id.x;
                    let localRow = local_id.y;
                    let localCol = local_id.x;
        
                    var acc : array<vec4<f32>, BATCH_SIZE>;
                    for (var b = 0u; b < BATCH_SIZE; b++) {
                        acc[b] = vec4<f32>(0.0, 0.0, 0.0, 0.0);
                    }
        
                    for (var t = 0u; t < uniforms.N; t += TILE_SIZE) {
                        // Collaborative loading of tiles into shared memory
                        for (var i = 0u; i < TILE_SIZE; i += 4u) {
                            if (t + i < uniforms.N && row < uniforms.N) {
                                let globalIdx = row * uniforms.N + t + i;
                                tileA[localRow][i / 4] = vec4<f32>(
                                    matrixA[globalIdx],
                                    matrixA[globalIdx + 1u],
                                    matrixA[globalIdx + 2u],
                                    matrixA[globalIdx + 3u]
                                );
                            }
                            if (t + localRow < uniforms.N && col < uniforms.N) {
                                let globalIdx = (t + localRow) * uniforms.N + col;
                                tileB[i / 4][localCol] = vec4<f32>(
                                    matrixB[globalIdx],
                                    matrixB[globalIdx + uniforms.N],
                                    matrixB[globalIdx + 2u * uniforms.N],
                                    matrixB[globalIdx + 3u * uniforms.N]
                                );
                            }
                        }
        
                        workgroupBarrier();
        
                        // Compute using tiles
                        for (var k = 0u; k < TILE_SIZE / 4u; k++) {
                            let aVec = tileA[localRow][k];
                            for (var b = 0u; b < BATCH_SIZE; b++) {
                                let bVec = tileB[k][localCol + b * ${x}u];
                                acc[b] += aVec * bVec;
                            }
                        }
        
                        workgroupBarrier();
                    }
        
                    // Write results
                    for (var b = 0u; b < BATCH_SIZE; b++) {
                        let writeCol = col + b * ${x}u;
                        if (row < uniforms.N && writeCol < uniforms.N) {
                            let index = row * uniforms.N + writeCol;
                            let sum = acc[b].x + acc[b].y + acc[b].z + acc[b].w;
                            matrixC[index] = uniforms.alpha * sum + uniforms.beta * matrixC[index];
                        }
                    }
                }
            `;
        }

        function getDecoupledAxisWGSL(workgroupSize, x, y) {
            const [wx, wy] = workgroupSize.split(',').map(Number);
            const ratio = x / y;
        
            if (ratio <= 2) {
                // Implementation for smaller ratios (2x128, 4x64, 8x32, 16x16)
                return `
                    @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                    @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                    @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                    @group(0) @binding(3) var<uniform> uniforms : Uniforms;
                    
                    struct Uniforms {
                        N : u32,
                        alpha : f32,
                        beta : f32,
                    }
        
                    var<workgroup> tileA: array<f32, ${x * y}>;
                    var<workgroup> tileB: array<f32, ${x * y}>;
        
                    @compute @workgroup_size(${wx}, ${wy})
                    fn main(
                        @builtin(global_invocation_id) global_id : vec3<u32>,
                        @builtin(local_invocation_id) local_id : vec3<u32>,
                        @builtin(workgroup_id) group_id : vec3<u32>
                    ) {
                        let N = uniforms.N;
                        let row = global_id.y;
                        let col = global_id.x;
                        let lid_row = local_id.y;
                        let lid_col = local_id.x;
                        
                        var acc = 0.0;
                        let numTiles = (N + ${x}u - 1u) / ${x}u;
                        
                        for (var t = 0u; t < numTiles; t = t + 1u) {
                            let tileStart = t * ${x}u;
                            let localIndex = lid_row * ${wx}u + lid_col;
                            
                            // Initialize shared memory
                            tileA[localIndex] = 0.0;
                            tileB[localIndex] = 0.0;
                            
                            workgroupBarrier();
        
                            // Load data only if within bounds
                            if (row < N && tileStart + lid_col < N) {
                                tileA[localIndex] = matrixA[row * N + tileStart + lid_col];
                            }
                            if (col < N && tileStart + lid_row < N) {
                                tileB[localIndex] = matrixB[(tileStart + lid_row) * N + col];
                            }
                            
                            workgroupBarrier();
        
                            // Compute only if within matrix bounds
                            if (row < N && col < N) {
                                for (var k = 0u; k < ${x}u && tileStart + k < N; k = k + 1u) {
                                    let aVal = tileA[lid_row * ${wx}u + k];
                                    let bVal = tileB[k * ${wy}u + lid_col];
                                    acc += aVal * bVal;
                                }
                            }
                            
                            workgroupBarrier();
                        }
        
                        // Write result only if within bounds
                        if (row < N && col < N) {
                            let index = row * N + col;
                            matrixC[index] = uniforms.alpha * acc + uniforms.beta * matrixC[index];
                        }
                    }
                `;
            } else {
                // Implementation for larger ratios (32x8, 64x4, 128x2)
                const blockSize = 16;
                return `
                    @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                    @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                    @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                    @group(0) @binding(3) var<uniform> uniforms : Uniforms;
                    
                    struct Uniforms {
                        N : u32,
                        alpha : f32,
                        beta : f32,
                    }
        
                    var<workgroup> tileA: array<array<f32, ${blockSize}>, ${blockSize}>;
                    var<workgroup> tileB: array<array<f32, ${blockSize}>, ${blockSize}>;
        
                    @compute @workgroup_size(${wx}, ${wy})
                    fn main(
                        @builtin(global_invocation_id) global_id : vec3<u32>,
                        @builtin(local_invocation_id) local_id : vec3<u32>,
                        @builtin(workgroup_id) group_id : vec3<u32>
                    ) {
                        let N = uniforms.N;
                        let baseRow = global_id.y;
                        let baseCol = global_id.x;
                        let lid_row = local_id.y;
                        let lid_col = local_id.x;
        
                        var acc = 0.0;
                        let numTiles = (N + ${blockSize}u - 1u) / ${blockSize}u;
        
                        for (var t = 0u; t < numTiles; t = t + 1u) {
                            let tileStart = t * ${blockSize}u;
        
                            // Initialize shared memory with zeros
                            for (var i = 0u; i < ${blockSize}u; i = i + 1u) {
                                tileA[lid_row][i] = 0.0;
                                tileB[i][lid_col] = 0.0;
                            }
                            
                            workgroupBarrier();
        
                            // Load data if within bounds
                            if (baseRow < N) {
                                for (var i = 0u; i < ${blockSize}u; i = i + 1u) {
                                    let loadCol = tileStart + i;
                                    if (loadCol < N) {
                                        tileA[lid_row][i] = matrixA[baseRow * N + loadCol];
                                    }
                                }
                            }
        
                            if (baseCol < N) {
                                for (var i = 0u; i < ${blockSize}u; i = i + 1u) {
                                    let loadRow = tileStart + i;
                                    if (loadRow < N) {
                                        tileB[i][lid_col] = matrixB[loadRow * N + baseCol];
                                    }
                                }
                            }
        
                            workgroupBarrier();
        
                            // Compute only if within bounds
                            if (baseRow < N && baseCol < N) {
                                for (var k = 0u; k < ${blockSize}u && tileStart + k < N; k = k + 1u) {
                                    acc += tileA[lid_row][k] * tileB[k][lid_col];
                                }
                            }
        
                            workgroupBarrier();
                        }
        
                        // Write result only if within bounds
                        if (baseRow < N && baseCol < N) {
                            let outIndex = baseRow * N + baseCol;
                            matrixC[outIndex] = uniforms.alpha * acc + uniforms.beta * matrixC[outIndex];
                        }
                    }
                `;
            }
        }

        function getGlobalTiledWGSL8x8(workgroupSize) {
            return getTiledWGSL(workgroupSize, 8, false);
        }
        
        function getSharedTiledWGSL8x8(workgroupSize) {
            return getTiledWGSL(workgroupSize, 8, true);
        }
        
        function getGlobalTiledWGSL16x16(workgroupSize) {
            return getTiledWGSL(workgroupSize, 16, false);
        }
        
        function getSharedTiledWGSL16x16(workgroupSize) {
            return getTiledWGSL(workgroupSize, 16, true);
        }
        
        function getSharedMemoryVectorizedWGSL_Tile4(workgroupSize) {
            return getSharedMemoryVectorizedWGSL(4, workgroupSize);
        }
        
        function getSharedMemoryVectorizedWGSL_Tile8(workgroupSize) {
            return getSharedMemoryVectorizedWGSL(8, workgroupSize);
        }
        
        function getSharedMemoryVectorizedWGSL_Tile16(workgroupSize) {
            return getSharedMemoryVectorizedWGSL(16, workgroupSize);
        }
        
        function getSharedMemoryVectorizedWGSL_Tile32(workgroupSize) {
            return getSharedMemoryVectorizedWGSL(32, workgroupSize);
        }

        function getGlobal1dTiling8(workgroupSize) {
            return get1dTiledWGSL(workgroupSize, 8, false);
        }
        
        function getShared1dTiling8(workgroupSize) {
            return get1dTiledWGSL(workgroupSize, 8, true);
        }
        
        function getGlobal1dTiling16(workgroupSize) {
            return get1dTiledWGSL(workgroupSize, 16, false);
        }
        
        function getShared1dTiling16(workgroupSize) {
            return get1dTiledWGSL(workgroupSize, 16, true);
        }
        
        function getDecoupledAxis2x128WGSL(workgroupSize) {
            return getDecoupledAxisWGSL(workgroupSize, 2, 128);
        }
        
        function getDecoupledAxis4x64WGSL(workgroupSize) {
            return getDecoupledAxisWGSL(workgroupSize, 4, 64);
        }
        
        function getDecoupledAxis8x32WGSL(workgroupSize) {
            return getDecoupledAxisWGSL(workgroupSize, 8, 32);
        }
        
        function getDecoupledAxis16x16WGSL(workgroupSize) {
            return getDecoupledAxisWGSL(workgroupSize, 16, 16);
        }
        
        function getDecoupledAxis32x8WGSL(workgroupSize) {
            return getDecoupledAxisWGSL(workgroupSize, 32, 8);
        }
        
        function getDecoupledAxis64x4WGSL(workgroupSize) {
            return getDecoupledAxisWGSL(workgroupSize, 64, 4);
        }
        
        function getDecoupledAxis128x2WGSL(workgroupSize) {
            return getDecoupledAxisWGSL(workgroupSize, 128, 2);
        }

        function verifyMatrixMultiplication(matrixA, matrixB, resultMatrix, N, alpha, beta, numChecks = 20) {
            for (let check = 0; check < numChecks; check++) {
                const row = Math.floor(Math.random() * N);
                const col = Math.floor(Math.random() * N);
                let expected = 0;
                for (let i = 0; i < N; i++) {
                    expected += matrixA[row * N + i] * matrixB[i * N + col];
                }
                expected = alpha * expected + beta * resultMatrix[row * N + col];
                const actual = resultMatrix[row * N + col];
                const relativeError = Math.abs((expected - actual) / expected);
                if (relativeError > 1e-5) {  // Allow for 0.001% relative error
                    console.error(`Verification failed at [${row}, ${col}]:`);
                    console.error(`  Expected: ${expected}`);
                    console.error(`  Actual: ${actual}`);
                    console.error(`  Relative Error: ${relativeError}`);
                    console.error(`  MatrixA values: ${matrixA.slice(row * N, (row + 1) * N)}`);
                    console.error(`  MatrixB column: ${Array.from({length: N}, (_, i) => matrixB[i * N + col])}`);
                    return false;
                }
            }
            return true;
        }

        async function runBenchmark(N, operationType, implementation, workgroupSize, tileSize) {
            let shaderModule;
            switch (implementation) {
                case 'naive':
                    shaderModule = device.createShaderModule({ code: getNaiveWGSL(workgroupSize) });
                    break;
                case 'gmemCoalescing':
                    shaderModule = device.createShaderModule({ code: getGMEMCoalescingWGSL(workgroupSize, tileSize) });
                    break;
                case 'smemCaching':
                    shaderModule = device.createShaderModule({ code: getSMEMCacheBlockingWGSL(workgroupSize, tileSize) });
                    break;
		case 'tiledDotProduct':
    		    shaderModule = device.createShaderModule({ code: getTiledDotProductWGSL(workgroupSize) });
    		    break;
                case 'vectorized':
                    shaderModule = device.createShaderModule({ code: getVectorizedWGSL(workgroupSize) });
                    break;
		case 'vectorized8ins':
 		    shaderModule = device.createShaderModule({ code: getVectorized8insWGSL(workgroupSize) });
    		    break;
		case 'vectorized16ins':
	            if (N < 16) {
	                // Fall back to regular vectorized implementation for small matrices
	                shaderModule = device.createShaderModule({ code: getVectorizedWGSL(workgroupSize) });
	            } else {
	                shaderModule = device.createShaderModule({ code: getVectorized16insWGSL(workgroupSize) });
	            }
	            break;
                case 'sharedMemoryVectorizedTile4':
                    shaderModule = device.createShaderModule({ code: getSharedMemoryVectorizedWGSL_Tile4(workgroupSize) });
                    break;
                case 'sharedMemoryVectorizedTile8':
                    shaderModule = device.createShaderModule({ code: getSharedMemoryVectorizedWGSL_Tile8(workgroupSize) });
                    break;
                case 'sharedMemoryVectorizedTile16':
                    shaderModule = device.createShaderModule({ code: getSharedMemoryVectorizedWGSL_Tile16(workgroupSize) });
                    break;
                case 'sharedMemoryVectorizedTile32':
                    shaderModule = device.createShaderModule({ code: getSharedMemoryVectorizedWGSL_Tile32(workgroupSize) });
                    break;
                case 'Global2dTiling8':
                    shaderModule = device.createShaderModule({ code: getGlobalTiledWGSL8x8(workgroupSize) });
                    break;
                case 'Shared2dTiling8':
                    shaderModule = device.createShaderModule({ code: getSharedTiledWGSL8x8(workgroupSize) });
                    break;
                case 'Global2dTiling16':
                    shaderModule = device.createShaderModule({ code: getGlobalTiledWGSL16x16(workgroupSize) });
                    break;
                case 'Shared2dTiling16':
                    shaderModule = device.createShaderModule({ code: getSharedTiledWGSL16x16(workgroupSize) });
                    break;
                case 'Global1dTiling8':
                    workgroupSize = '256'; // Override for optimal performance
                    shaderModule = device.createShaderModule({ 
                        code: get1dTiledWGSL(parseInt(workgroupSize), 8, false) 
                    });
                    break;
                case 'Shared1dTiling8':
                    workgroupSize = '256'; // Override for optimal performance
                    shaderModule = device.createShaderModule({ 
                        code: get1dTiledWGSL(parseInt(workgroupSize), 8, true) 
                    });
                    break;
                case 'Global1dTiling16':
                    workgroupSize = '256'; // Override for optimal performance
                    shaderModule = device.createShaderModule({ 
                        code: get1dTiledWGSL(parseInt(workgroupSize), 16, false) 
                    });
                    break;
                case 'Shared1dTiling16':
                    workgroupSize = '256'; // Override for optimal performance
                    shaderModule = device.createShaderModule({ 
                        code: get1dTiledWGSL(parseInt(workgroupSize), 16, true) 
                    });
                    break;
               case 'DecoupledAxis2x128':
                   shaderModule = device.createShaderModule({ 
                       code: getDecoupledAxis2x128WGSL(workgroupSize) 
                   });
                   break;
               case 'DecoupledAxis4x64':
                   shaderModule = device.createShaderModule({ 
                       code: getDecoupledAxis4x64WGSL(workgroupSize) 
                   });
                   break;
               case 'DecoupledAxis8x32':
                   shaderModule = device.createShaderModule({ 
                       code: getDecoupledAxis8x32WGSL(workgroupSize) 
                   });
                   break;
               case 'DecoupledAxis16x16':
                   shaderModule = device.createShaderModule({ 
                       code: getDecoupledAxis16x16WGSL(workgroupSize) 
                   });
                   break;
               case 'DecoupledAxis32x8':
                   shaderModule = device.createShaderModule({ 
                       code: getDecoupledAxis32x8WGSL(workgroupSize) 
                   });
                   break;
               case 'DecoupledAxis64x4':
                   shaderModule = device.createShaderModule({ 
                       code: getDecoupledAxis64x4WGSL(workgroupSize) 
                   });
                   break;
               case 'DecoupledAxis128x2':
                   shaderModule = device.createShaderModule({ 
                       code: getDecoupledAxis128x2WGSL(workgroupSize) 
                   });
                   break;
                default:
                    return { time: 0, verified: false };
            }

    const { bufferA, bufferB, bufferAVec4, bufferBVec4, matrixA, matrixB } = generatedMatrices[N];
    const matrixSize = N * N;
    const resultMatrix = new Float32Array(matrixSize);
    const bufferC = createBuffer(resultMatrix, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);

    const uniformBuffer = device.createBuffer({
        size: 16,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    const uniformData = new ArrayBuffer(16);
    new Uint32Array(uniformData, 0, 1)[0] = N;
    new Float32Array(uniformData, 4, 2).set([1.0, 0.0]); // alpha = 1.0, beta = 0.0
    device.queue.writeBuffer(uniformBuffer, 0, uniformData);

    const bindGroupLayout = device.createBindGroupLayout({
        entries: [
            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
            { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
        ],
    });

    const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
            { binding: 0, resource: { buffer: bufferA } },
            { binding: 1, resource: { buffer: bufferB } },
            { binding: 2, resource: { buffer: bufferC } },
            { binding: 3, resource: { buffer: uniformBuffer } },
        ],
    });
    const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout],
    });

    const computePipeline = device.createComputePipeline({
        layout: pipelineLayout,
        compute: {
            module: shaderModule,
            entryPoint: "main",
        },
    });

    const commandEncoder = device.createCommandEncoder();
    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(computePipeline);
    passEncoder.setBindGroup(0, bindGroup);

    if (implementation.includes('1dTiling')) {
        const workgroupSizeX = parseInt(workgroupSize);
        const totalElements = N * N;
        const elementsPerChunk = 65535 * workgroupSizeX;
        const numChunks = Math.ceil(totalElements / elementsPerChunk);
    
        // Process the matrix in chunks
        for (let chunk = 0; chunk < numChunks; chunk++) {
            // Update uniform buffer with current chunk offset
            const uniformData = new ArrayBuffer(16);
            new Uint32Array(uniformData, 0, 1)[0] = N;
            new Float32Array(uniformData, 4, 2).set([1.0, 0.0]); // alpha and beta
            new Uint32Array(uniformData, 12, 1)[0] = chunk; // chunkOffset
            device.queue.writeBuffer(uniformBuffer, 0, uniformData);
    
            const remainingElements = Math.min(elementsPerChunk, totalElements - chunk * elementsPerChunk);
            const numWorkgroupsThisChunk = Math.ceil(remainingElements / workgroupSizeX);
    
            passEncoder.dispatchWorkgroups(Math.min(65535, numWorkgroupsThisChunk), 1, 1);
        }
    }
     else {
        const [x, y] = workgroupSize.split(',').map(Number);
        passEncoder.dispatchWorkgroups(Math.ceil(N / x), Math.ceil(N / y));
    }
    passEncoder.end();

    const startTime = performance.now();
    device.queue.submit([commandEncoder.finish()]);
    await device.queue.onSubmittedWorkDone();
    const endTime = performance.now();

    // Read back the result for verification
    const resultReadBuffer = device.createBuffer({
        size: bufferC.size,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    const readBackEncoder = device.createCommandEncoder();
    readBackEncoder.copyBufferToBuffer(bufferC, 0, resultReadBuffer, 0, bufferC.size);
    device.queue.submit([readBackEncoder.finish()]);
    await resultReadBuffer.mapAsync(GPUMapMode.READ);
    const resultArray = new Float32Array(resultReadBuffer.getMappedRange());

    const isVerified = verifyMatrixMultiplication(matrixA, matrixB, resultArray, N, 1.0, 0.0);

    resultReadBuffer.unmap();

    return { time: endTime - startTime, verified: isVerified };
    }
        async function checkWebGPUSupport() {
            if (!navigator.gpu) {
                return false;
            }
            try {
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    return false;
                }
                return true;
            } catch (e) {
                return false;
            }
        }
        
        async function updateUIForSupport() {
            const isSupported = await checkWebGPUSupport();
            const unsupportedMessage = document.getElementById('unsupportedMessage');
            const benchmarkControls = document.getElementById('benchmarkControls');
            
            if (!isSupported) {
                unsupportedMessage.style.display = 'block';
                unsupportedMessage.textContent = 'WebGPU is not supported on this device. The benchmark cannot run.';
                benchmarkControls.style.display = 'none';
            } else {
                unsupportedMessage.style.display = 'none';
                benchmarkControls.style.display = 'block';
            }
        }
        
        window.addEventListener('load', updateUIForSupport);

        async function performBenchmark() {
            const operationTypes = ['gemm', 'gemv'].filter(op => document.getElementById(op).checked);
	    const implementations = [
	    'naive', 
	    'gmemCoalescing', 
	    'smemCaching', 
	    'tiledDotProduct',
	    'vectorized', 
	    'vectorized8ins', 
	    'vectorized16ins',
	    'sharedMemoryVectorizedTile4', 
	    'sharedMemoryVectorizedTile8', 
	    'sharedMemoryVectorizedTile16', 
	    'sharedMemoryVectorizedTile32', 
	    'Global2dTiling8', 
	    'Shared2dTiling8', 
	    'Global2dTiling16', 
	    'Shared2dTiling16', 
	    'Global1dTiling8', 
	    'Shared1dTiling8', 
	    'Global1dTiling16', 
	    'Shared1dTiling16', 
	    'sharedMemoryVectorizedTileBatched',     
	    'DecoupledAxis2x128',
    	    'DecoupledAxis4x64',
            'DecoupledAxis8x32',
            'DecoupledAxis16x16',
            'DecoupledAxis32x8',
            'DecoupledAxis64x4',
            'DecoupledAxis128x2'].filter(impl => document.getElementById(impl).checked);
            const matrixSizes = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096].filter(size => document.getElementById(`size${size}`).checked);
            const iterations = parseInt(document.getElementById('iterationNumber').value);
            const selectedWorkgroupSizes = Array.from(document.querySelectorAll('input[name="workgroupSize"]:checked')).map(cb => cb.value);
            const selectedTileSizes = Array.from(document.querySelectorAll('input[name="tileSize"]:checked')).map(cb => parseInt(cb.value));

            const results = {};
            const resultsTables = document.getElementById('resultsTables');
            resultsTables.innerHTML = ''; // Clear previous results
 
                for (const implementation of implementations) {
                let workgroupSizes;
                let tileSizes;

                switch (implementation) {
                    case 'naive':
                    case 'gmemCoalescing':
                        workgroupSizes = selectedWorkgroupSizes;
                        tileSizes = implementation === 'gmemCoalescing' ? selectedTileSizes : [16];
                        break;
                    case 'sharedMemoryVectorizedTile4':
                        workgroupSizes = ['4,4'];
                        tileSizes = [4];
                        break;
                    case 'sharedMemoryVectorizedTile8':
                        workgroupSizes = ['8,8'];
                        tileSizes = [8];
                        break;
                    case 'sharedMemoryVectorizedTile16':
                        workgroupSizes = ['16,16'];
                        tileSizes = [16];
                        break;
                    case 'sharedMemoryVectorizedTile32':
                        workgroupSizes = ['32,32'];
                        tileSizes = [32];
                        break;
                    case 'Global2dTiling8':
                        workgroupSizes = ['8,8'];
                        tileSizes = [8];
                        break;
                    case 'Shared2dTiling8':
                        workgroupSizes = ['8,8'];
                        tileSizes = [8];
                        break;
                    case 'Global2dTiling16':
                        workgroupSizes = ['16,16'];
                        tileSizes = [16];
                        break;
                    case 'Shared2dTiling16':
                        workgroupSizes = ['16,16'];
                        tileSizes = [16];
                        break;
                    case 'Global2dTiling32':
                        workgroupSizes = ['32,32'];
                        tileSizes = [32];
                        break;
                    case 'Shared2dTiling32':
                        workgroupSizes = ['32,32'];
                        tileSizes = [32];
                        break;
	            case 'Global1dTiling8':
                    case 'Shared1dTiling8':
                        workgroupSizes = ['32'];
                        tileSizes = [8];
                        break;
                    case 'Global1dTiling16':
                    case 'Shared1dTiling16':
                        workgroupSizes = ['128'];
                        tileSizes = [16];
                        break;
		    case 'sharedMemoryVectorizedTileBatched':
                        workgroupSizes = ['16,16'];
                        tileSizes = [16];
                        break;
                    case 'DecoupledAxis2x128':
                    case 'DecoupledAxis4x64':
                    case 'DecoupledAxis8x32':
                    case 'DecoupledAxis16x16':
                    case 'DecoupledAxis32x8':
                    case 'DecoupledAxis64x4':
                    case 'DecoupledAxis128x2':
                        workgroupSizes = ['16,16']; // Default workgroup size
                        tileSizes = [16]; // Default tile size
                        break;
                    default:
                        workgroupSizes = ['16,16'];
                        tileSizes = [16];
                }

                for (const workgroupSize of workgroupSizes) {
                    for (const tileSize of tileSizes) {
                        const implementationKey = `${implementation}-${workgroupSize}-${tileSize}`;
                        results[implementationKey] = [];
                        const table = document.createElement('table');
                        table.innerHTML = `
                            <thead>
                                <tr>
                                    <th>Operation Type</th>
                                    <th>Matrix Size</th>
                                    <th>Number of Iterations</th>
                                    <th>Time (ms)</th>
                                    <th>GFLOPS</th>
                                    <th>Verified</th>
                                    <th>Tuning Parameters</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        `;
                        const tableBody = table.querySelector('tbody');

                        for (const operationType of operationTypes) {
                            for (const N of matrixSizes) {
                                if (!generatedMatrices[N]) {
                                    console.error(`Matrices for size ${N} have not been generated. Skipping...`);
                                    continue;
                                }

                                try {
                                    // Warm-up run
                                    await runBenchmark(N, operationType, implementation, workgroupSize, tileSize);

                                    let totalTime = 0;
                                    let allVerified = true;
                                    for (let i = 0; i < iterations; i++) {
                                        const { time, verified } = await runBenchmark(N, operationType, implementation, workgroupSize, tileSize);
                                        totalTime += time;
                                        allVerified = allVerified && verified;
                                    }
                                    const averageTime = totalTime / iterations;
                                    const gflops = averageTime > 0 ? (2 * N * N * N) / (averageTime * 1e6) : 0;

                                    const result = {
                                        operationType,
                                        size: N,
                                        time: averageTime,
                                        gflops,
                                        verified: allVerified,
                                        tuningParameters: `Workgroup Size ${workgroupSize}, Tile Size ${tileSize}`
                                    };

                                    results[implementationKey].push(result);

                                    // Add row to the results table
                                    const row = tableBody.insertRow();
                                    row.innerHTML = `
                                        <td>${operationType.toUpperCase()}</td>
                                        <td>${N}</td>
                                        <td>${iterations}</td>
                                        <td>${averageTime.toFixed(2)}</td>
                                        <td>${gflops.toFixed(2)}</td>
                                        <td>${allVerified ? "" : ""}</td>
                                        <td>${result.tuningParameters}</td>
                                    `;

                                    console.log(`Operation: ${operationType}, Size: ${N}, ${implementation} (${workgroupSize}, ${tileSize}): ${averageTime.toFixed(2)} ms, ${gflops.toFixed(2)} GFLOPS, Verified: ${allVerified}, Tuning Parameters: ${result.tuningParameters}`);
                                } catch (error) {
                                    console.error(`Error running benchmark for ${implementation} (${workgroupSize}, ${tileSize}) with size ${N}:`, error);
                                    const row = tableBody.insertRow();
                                    row.innerHTML = `
                                        <td>${operationType.toUpperCase()}</td>
                                        <td>${N}</td>
                                        <td colspan="5">Error: ${error.message}</td>
                                    `;
                                }
                            }
                        }

                        const implementationTitle = document.createElement('h3');
                        implementationTitle.textContent = `Results for ${implementation} (Workgroup Size: ${workgroupSize}, Tile Size: ${tileSize})`;
                        resultsTables.appendChild(implementationTitle);
                        resultsTables.appendChild(table);
                    }
                }
            }

            updateChart(results);
        }

    let benchmarkChart;
    function updateChart(results) {
    const ctx = document.getElementById("benchmarkChart").getContext("2d");

    if (benchmarkChart && typeof benchmarkChart.destroy === 'function') {
        benchmarkChart.destroy();
    }

    const datasets = [];
    const operationTypes = ['gemm', 'gemv'];
    const implementations = Object.keys(results);
    const colors = ['red', 'blue', 'green', 'purple', 'orange', 'pink', 'cyan', 'magenta', 'yellow', 'black'];
    const matrixSizes = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];

    let minTime = Infinity;
    let maxTime = -Infinity;

    implementations.forEach((implementation, index) => {
        operationTypes.forEach(operationType => {
            const data = matrixSizes.map(size => {
                const result = results[implementation].find(r => r.operationType === operationType && r.size === size);
                if (result) {
                    minTime = Math.min(minTime, result.time);
                    maxTime = Math.max(maxTime, result.time);
                }
                return result ? result.time : null;
            });

            if (data.some(v => v !== null)) {
                datasets.push({
                    label: `${operationType.toUpperCase()} - ${implementation}`,
                    data: data,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length],
                    fill: false,
                    borderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    spanGaps: true
                });
            }
        });
    });

    const yAxisConfig = {
        logarithmic: {
            type: 'logarithmic',
            title: {
                display: true,
                text: 'Time (Log Scale)'
            },
            ticks: {
                callback: function(value, index, values) {
                    if (value >= 1000) {
                        return (value / 1000).toFixed(1) + 's';
                    }
                    return value.toFixed(0) + 'ms';
                },
                maxTicksLimit: 6
            }
        },
        linear: {
            type: 'linear',
            title: {
                display: true,
                text: 'Time (Linear Scale)'
            },
            ticks: {
                callback: function(value, index, values) {
                    if (value >= 1000) {
                        return (value / 1000).toFixed(1) + 's';
                    }
                    return value.toFixed(0) + 'ms';
                },
                maxTicksLimit: 8
            }
        }
    };

    let currentYAxisType = 'logarithmic';

    benchmarkChart = new Chart(ctx, {
        type: "line",
        data: {
            labels: matrixSizes,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            title: {
                display: true,
                text: 'Matrix Multiplication Performance'
            },
            scales: {
                x: {
                    type: 'category',
                    title: {
                        display: true,
                        text: 'Matrix Size'
                    },
                    ticks: {
                        autoSkip: false,
                        maxRotation: 0,
                        minRotation: 0
                    }
                },
                y: yAxisConfig.logarithmic
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += `${context.parsed.y.toFixed(2)} ms`;
                            }
                            return label;
                        }
                    }
                },
                zoom: {
                    zoom: {
                        wheel: {
                            enabled: false,
                        },
                        pinch: {
                            enabled: false
                        },
                        mode: 'xy',
                    },
                    pan: {
                        enabled: true,
                        mode: 'xy',
			threshold: 10,
                    }
                }
            }
        }
    });

    // Add toggle button for y-axis scale
    const toggleButton = document.createElement('button');
    toggleButton.textContent = 'Toggle Y-Axis Scale';
    toggleButton.style.marginTop = '10px';
    ctx.canvas.parentNode.insertBefore(toggleButton, ctx.canvas.nextSibling);

    toggleButton.addEventListener('click', () => {
        currentYAxisType = currentYAxisType === 'logarithmic' ? 'linear' : 'logarithmic';
        benchmarkChart.options.scales.y = yAxisConfig[currentYAxisType];
        
        if (currentYAxisType === 'linear') {
            // Set a custom range for linear scale to focus on the data
            const range = maxTime - minTime;
            benchmarkChart.options.scales.y.min = Math.max(0, minTime - range * 0.1);
            benchmarkChart.options.scales.y.max = maxTime + range * 0.1;
        } else {
            // Reset range for logarithmic scale
            delete benchmarkChart.options.scales.y.min;
            delete benchmarkChart.options.scales.y.max;
        }

        benchmarkChart.update();
        });
	updateBestMethodsSummary(results);
    }
        function downloadResults() {
            const tables = document.querySelectorAll('#resultsTables table');
            let csv = [];

            tables.forEach((table, index) => {
                const implementation = table.previousElementSibling.textContent.replace('Results for ', '');
                csv.push(`Implementation: ${implementation}`);

                for (let i = 0; i < table.rows.length; i++) {
                    let row = [], cols = table.rows[i].cells;
                    for (let j = 0; j < cols.length; j++) {
                        row.push(cols[j].innerText);
                    }
                    csv.push(row.join(","));
                }

                csv.push(''); // Add an empty line between tables
            });

            let csvContent = "data:text/csv;charset=utf-8," + csv.join("\n");
            let encodedUri = encodeURI(csvContent);
            let link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "benchmark_results.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        document.getElementById("runBenchmark").addEventListener("click", performBenchmark);
        document.getElementById("downloadResults").addEventListener("click", downloadResults);

        document.getElementById("selectSizes").addEventListener("click", () => {
            const selectedSizes = Array.from(document.querySelectorAll('.size-checkbox:checked')).map(cb => parseInt(cb.value));
            generateMatrices(selectedSizes);
        });

        document.getElementById("selectAllSizes").addEventListener("click", () => {
            document.querySelectorAll('.size-checkbox').forEach(cb => cb.checked = true);
            const allSizes = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
            generateMatrices(allSizes);
        });

        document.getElementById("resetSizes").addEventListener("click", () => {
            document.querySelectorAll('.size-checkbox').forEach(cb => cb.checked = false);
            generatedMatrices = {};
            document.getElementById("generateButton").textContent = "Generating";
            document.getElementById("generateButton").style.backgroundColor = "yellow";
            document.getElementById("generateButton").style.color = "black";
        });

        document.getElementById("selectAllMethods").addEventListener("click", () => {
            document.querySelectorAll('.multiplication-methods-tile input[type="checkbox"]').forEach(cb => cb.checked = true);
        });

        document.getElementById("resetMethods").addEventListener("click", () => {
            document.querySelectorAll('.multiplication-methods-tile input[type="checkbox"]').forEach(cb => cb.checked = false);
        });

        document.getElementById("resetBenchmark").addEventListener("click", () => {
            document.getElementById('iterationNumber').value = '16';
            document.getElementById('resultsTables').innerHTML = '';
            if (benchmarkChart && typeof benchmarkChart.destroy === 'function') {
                benchmarkChart.destroy();
                benchmarkChart = null;
            }
        });

        document.getElementById("selectAllTuningMethods").addEventListener("click", () => {
            document.querySelectorAll('input[name="workgroupSize"]').forEach(cb => cb.checked = true);
            document.querySelectorAll('input[name="tileSize"]').forEach(cb => cb.checked = true);
        });

        async function updateDeviceInfo() {
            const deviceInfoElement = document.getElementById("deviceInfo");
            try {
                if (!navigator.gpu) {
                    throw new Error("WebGPU not supported on this browser.");
                }
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error("No appropriate GPUAdapter found.");
                }
                const device = await adapter.requestDevice();
                const adapterInfo = await adapter.requestAdapterInfo();
                
                deviceInfoElement.innerHTML = `
                    <strong>GPU Vendor:</strong> ${adapterInfo.vendor}<br>
                    <strong>GPU Architecture:</strong> ${adapterInfo.architecture}<br>
                    <strong>Max Workgroup Size:</strong>
                    X: ${device.limits.maxComputeWorkgroupSizeX},
                    Y: ${device.limits.maxComputeWorkgroupSizeY},
                    Z: ${device.limits.maxComputeWorkgroupSizeZ}<br>
                    <strong>Max Workgroup Storage:</strong> ${device.limits.maxComputeWorkgroupStorageSize} bytes<br>
                    <strong>Max Invocations Per Workgroup:</strong> ${device.limits.maxComputeInvocationsPerWorkgroup}<br>
                    <strong>Max Storage Buffer Binding Size:</strong> ${device.limits.maxStorageBufferBindingSize} bytes<br>
                    <strong>Max Compute Workgroups Per Dimension:</strong>
                    X: ${device.limits.maxComputeWorkgroupsPerDimension},
                    Y: ${device.limits.maxComputeWorkgroupsPerDimension},
                    Z: ${device.limits.maxComputeWorkgroupsPerDimension}
                `;
            } catch (error) {
                console.error("Error updating device info:", error);
                deviceInfoElement.innerHTML = `
                    <strong>Device:</strong> ${navigator.platform}<br>
                    <strong>Browser:</strong> ${navigator.userAgent}<br>
                    <strong>WebGPU Support:</strong> Not available<br>
                    <strong>Error:</strong> ${error.message}
                `;
            }
        }
        // Initialize WebGPU when the page loads
        window.onload = async function() {
            try {
                await initializeWebGPU();
                updateDeviceInfo();
            } catch (error) {
                console.error("Failed to initialize WebGPU:", error);
                document.getElementById("deviceInfo").textContent = "WebGPU initialization failed: " + error.message;
            }
        };
    </script>
</body>
</html>
