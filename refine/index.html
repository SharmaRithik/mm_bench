<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Multiplication Benchmark</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .tile {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-container {
            height: 500px;
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
        }
        .matrix-sizes {
            margin: 10px 0;
        }
        .config-section {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .config-section h4 {
            margin-top: 0;
        }
        .workgroup-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .workgroup-options label {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #sizeCheckboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        #sizeCheckboxes label {
            white-space: nowrap;
        }
        .button-group {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            margin-left: 16px;
        }
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .small-button {
            padding: 4px 8px;
            font-size: 12px;
            background-color: #6c757d;
        }
        .bar-charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            padding: 10px;
        }
        .bar-chart-wrapper {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            height: 400px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="tile">
            <h2>Matrix Multiplication Benchmark</h2>
            <div id="deviceInfo"></div>
        </div>
        
        <div class="tile">
            <h3>Configuration</h3>
            <div class="config-section">
                <div class="section-header">
                    <h4>Matrix Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleMatrixSizes('reset')">Reset</button>
                        <button class="small-button" onclick="handleMatrixSizes('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="sizeCheckboxes"></div>
            </div>
            
            <div class="config-section">
                <div class="section-header">
                    <h4>Naive Implementation Workgroups</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleWorkgroups('reset')">Reset</button>
                        <button class="small-button" onclick="handleWorkgroups('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="naiveWorkgroups" class="workgroup-options"></div>
            </div>

            <div class="config-section">
                <label for="iterations">Number of iterations:</label>
                <input type="number" id="iterations" value="1" min="1" max="100">
            </div>

            <div>
                <button id="generateMatrices">Generate Matrices</button>
                <button id="runBenchmark">Run Benchmark</button>
                <button id="downloadResults">Download Results</button>
            </div>
        </div>

        <div class="tile">
            <h3>Results</h3>
            <div id="resultsTable"></div>
        </div>

        <div class="tile">
            <h3>Performance Comparison</h3>
            <div class="chart-container">
                <canvas id="benchmarkChart"></canvas>
            </div>
        </div>

        <div class="tile">
            <h3>Performance by Matrix Size</h3>
            <div id="barChartsContainer" class="bar-charts-container">
                <!-- Bar charts will be dynamically added here -->
            </div>
        </div>
    </div>
    <script>
        // Configuration
        const matrixSizes = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];

        // Generate workgroup sizes based on the specified logic
        const naiveWorkgroupSizes = [];
        for (let x = 0; x <= 8; x++) {
            for (let y = 0; y <= 8; y++) {
                const xDim = Math.pow(2, x);
                const yDim = Math.pow(2, y);
                if (xDim * yDim <= 256) {
                    naiveWorkgroupSizes.push(`${xDim},${yDim}`);
                }
            }
        }

        let device;
        let generatedMatrices = {};
        let benchmarkChart;
        let results = {
            naive: []
        };

        // Handle matrix size selection buttons
        function handleMatrixSizes(action) {
            const checkboxes = document.querySelectorAll('#sizeCheckboxes input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (action === 'reset') {
                    checkbox.checked = false;
                } else if (action === 'selectAll') {
                    checkbox.checked = true;
                }
            });
        }

        // Handle workgroup selection buttons
        function handleWorkgroups(action) {
            const checkboxes = document.querySelectorAll('#naiveWorkgroups input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (action === 'reset') {
                    checkbox.checked = false;
                } else if (action === 'selectAll') {
                    checkbox.checked = true;
                }
            });
        }

        // Naive WGSL implementation
        function getNaiveWGSL(workgroupSize) {
            const [wx, wy] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;

                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }

                @compute @workgroup_size(${wx}, ${wy})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                    let N = uniforms.N;
                    let row = global_id.y;
                    let col = global_id.x;

                    if (row >= N || col >= N) {
                        return;
                    }

                    let row_offset = row * N;
                    var sum: f32 = 0.0;

                    for (var k = 0u; k < N; k = k + 1u) {
                        let a = matrixA[row_offset + k];
                        let b = matrixB[k * N + col];
                        sum = sum + a * b;
                    }

                    matrixC[row_offset + col] = uniforms.alpha * sum + uniforms.beta * matrixC[row_offset + col];
                }
            `;
        }

        // Initialize WebGPU
        async function initWebGPU() {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported");
            }
            const adapter = await navigator.gpu.requestAdapter();
            device = await adapter.requestDevice();
            return device;
        }

        // Create buffer helper function
        function createBuffer(data, usage) {
            const buffer = device.createBuffer({
                size: data.byteLength,
                usage: usage,
                mappedAtCreation: true,
            });
            new Float32Array(buffer.getMappedRange()).set(data);
            buffer.unmap();
            return buffer;
        }

        // Generate matrices
        async function generateMatrices(sizes) {
            for (const N of sizes) {
                const matrixSize = N * N;
                const matrixA = new Float32Array(matrixSize);
                const matrixB = new Float32Array(matrixSize);

                for (let i = 0; i < matrixSize; i++) {
                    matrixA[i] = Math.random();
                    matrixB[i] = Math.random();
                }

                const bufferA = createBuffer(matrixA, GPUBufferUsage.STORAGE);
                const bufferB = createBuffer(matrixB, GPUBufferUsage.STORAGE);

                generatedMatrices[N] = { bufferA, bufferB, matrixA, matrixB };
            }
        }

        // Verify matrix multiplication
        function verifyMatrixMultiplication(matrixA, matrixB, resultMatrix, N, alpha, beta) {
            for (let check = 0; check < 5; check++) {
                const row = Math.floor(Math.random() * N);
                const col = Math.floor(Math.random() * N);
                let expected = 0;
                for (let i = 0; i < N; i++) {
                    expected += matrixA[row * N + i] * matrixB[i * N + col];
                }
                expected = alpha * expected + beta * 0;
                const actual = resultMatrix[row * N + col];
                const relativeError = Math.abs((expected - actual) / expected);
                if (relativeError > 1e-5) {
                    return false;
                }
            }
            return true;
        }
	async function runBenchmark(N, workgroupSize) {
            const shaderModule = device.createShaderModule({
                code: getNaiveWGSL(workgroupSize)
            });

            const { bufferA, bufferB, matrixA, matrixB } = generatedMatrices[N];
            const matrixSize = N * N;
            const resultMatrix = new Float32Array(matrixSize).fill(0);
            const bufferC = createBuffer(resultMatrix, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);

            const uniformBuffer = device.createBuffer({
                size: 16,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });

            const uniformData = new ArrayBuffer(16);
            new Uint32Array(uniformData, 0, 1)[0] = N;
            new Float32Array(uniformData, 4, 1)[0] = 1.0;
            new Float32Array(uniformData, 8, 1)[0] = 0.0;
            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
                    { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
                ],
            });

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: bufferA } },
                    { binding: 1, resource: { buffer: bufferB } },
                    { binding: 2, resource: { buffer: bufferC } },
                    { binding: 3, resource: { buffer: uniformBuffer } },
                ],
            });

            const pipeline = device.createComputePipeline({
                layout: device.createPipelineLayout({
                    bindGroupLayouts: [bindGroupLayout],
                }),
                compute: {
                    module: shaderModule,
                    entryPoint: "main",
                },
            });

            const commandEncoder = device.createCommandEncoder();
            const passEncoder = commandEncoder.beginComputePass();
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);

            const [x, y] = workgroupSize.split(',').map(Number);
            passEncoder.dispatchWorkgroups(Math.ceil(N / x), Math.ceil(N / y));
            passEncoder.end();

            const startTime = performance.now();
            device.queue.submit([commandEncoder.finish()]);
            await device.queue.onSubmittedWorkDone();
            const endTime = performance.now();

            const resultReadBuffer = device.createBuffer({
                size: bufferC.size,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });

            const readbackEncoder = device.createCommandEncoder();
            readbackEncoder.copyBufferToBuffer(bufferC, 0, resultReadBuffer, 0, bufferC.size);
            device.queue.submit([readbackEncoder.finish()]);

            await resultReadBuffer.mapAsync(GPUMapMode.READ);
            const resultArray = new Float32Array(resultReadBuffer.getMappedRange());
            const isVerified = verifyMatrixMultiplication(matrixA, matrixB, resultArray, N, 1.0, 0.0);
            resultReadBuffer.unmap();

            return {
                time: endTime - startTime,
                verified: isVerified
            };
        }

        // Create bar charts
        function createBarCharts() {
            const barChartsContainer = document.getElementById('barChartsContainer');
            barChartsContainer.innerHTML = ''; // Clear existing charts

            // Get unique matrix sizes from results
            const matrixSizes = [...new Set(results.naive.map(r => r.size))].sort((a, b) => a - b);

            // Create a bar chart for each matrix size
            matrixSizes.forEach(size => {
                // Filter results for this size
                const sizeResults = results.naive.filter(r => r.size === size);

                // Sort results by time for better visualization
                sizeResults.sort((a, b) => a.time - b.time);

                console.log(`Data for size ${size}:`, sizeResults); // Debug log

                // Create wrapper div for this chart
                const chartWrapper = document.createElement('div');
                chartWrapper.className = 'bar-chart-wrapper';
                const canvas = document.createElement('canvas');
                chartWrapper.appendChild(canvas);
                barChartsContainer.appendChild(chartWrapper);

                // Calculate the maximum time for setting y-axis scale
                const maxTime = Math.max(...sizeResults.map(r => r.time));
                const yAxisMax = Math.ceil(maxTime * 1.1); // Add 10% padding

                // Create the bar chart
                new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: sizeResults.map(r => `Naive (${r.workgroupSize.replace(',', 'x')})`),
                        datasets: [{
                            label: 'Execution Time',
                            data: sizeResults.map(r => r.time),
                            backgroundColor: 'rgba(255, 99, 132, 0.8)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `Performance for ${size}x${size} Matrix`,
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            },
                            subtitle: {
                                display: true,
                                text: 'Lower time is better',
                                padding: 10
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: yAxisMax,
                                title: {
                                    display: true,
                                    text: 'Time (ms)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Method & Workgroup Size'
                                },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            }
                        },
                        layout: {
                            padding: {
                                left: 20,
                                right: 20,
                                top: 20,
                                bottom: 40
                            }
                        }
                    }
                });
            });
        }

        // Perform benchmark
        async function performBenchmark() {
            const iterations = parseInt(document.getElementById('iterations').value);
            const selectedSizes = Array.from(document.querySelectorAll('#sizeCheckboxes input:checked'))
                .map(cb => parseInt(cb.value));

            const selectedWorkgroups = Array.from(document.querySelectorAll('#naiveWorkgroups input:checked'))
                .map(cb => cb.value);

            if (selectedWorkgroups.length === 0) {
                alert('Please select at least one workgroup size');
                return;
            }

            results = { naive: [] };

            const resultsTable = document.getElementById('resultsTable');
            resultsTable.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Matrix Size</th>
                            <th>Workgroup Size</th>
                            <th>Average Time (ms)</th>
                            <th>GFLOPS</th>
                            <th>Verified</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            `;
            const tbody = resultsTable.querySelector('tbody');

            for (const size of selectedSizes) {
                for (const workgroupSize of selectedWorkgroups) {
                    // Warm-up run
                    await runBenchmark(size, workgroupSize);

                    let totalTime = 0;
                    let allVerified = true;

                    for (let i = 0; i < iterations; i++) {
                        const result = await runBenchmark(size, workgroupSize);
                        totalTime += result.time;
                        allVerified = allVerified && result.verified;
                    }

                    const avgTime = totalTime / iterations;
                    const gflops = (2 * size * size * size) / (avgTime * 1e6);

                    results.naive.push({
                        size,
                        workgroupSize,
                        time: parseFloat(avgTime.toFixed(2)),
                        gflops: parseFloat(gflops.toFixed(2)),
                        verified: allVerified
                    });

                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${size}x${size}</td>
                        <td>${workgroupSize}</td>
                        <td>${avgTime.toFixed(2)}</td>
                        <td>${gflops.toFixed(2)}</td>
                        <td>${allVerified ? '✓' : '✗'}</td>
                    `;
                }
            }

            console.log('Final results:', results.naive); // Debug log
            updateChart();
            createBarCharts();
        }

        // Update chart
        function updateChart() {
            const ctx = document.getElementById('benchmarkChart').getContext('2d');

            if (benchmarkChart) {
                benchmarkChart.destroy();
            }

            const datasets = [];
            const colors = [
                'rgb(75, 192, 192)', 'rgb(255, 99, 132)', 'rgb(54, 162, 235)',
                'rgb(255, 206, 86)', 'rgb(153, 102, 255)', 'rgb(255, 159, 64)'
            ];

            const workgroupSizes = [...new Set(results.naive.map(r => r.workgroupSize))];
            workgroupSizes.forEach((wg, index) => {
                const filteredResults = results.naive.filter(r => r.workgroupSize === wg);
                datasets.push({
                    label: `Workgroup ${wg.replace(',', 'x')}`,
                    data: filteredResults.map(r => r.time),
                    borderColor: colors[index % colors.length],
                    tension: 0.1
                });
            });

            benchmarkChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [...new Set(results.naive.map(r => `${r.size}x${r.size}`))],
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Matrix Size'
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: 'Time (ms)'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Matrix Multiplication Performance Comparison'
                        }
                    }
                }
            });
        }

        // Download results
        function downloadResults() {
            const csv = [
                'Matrix Size,Workgroup Size,Time (ms),GFLOPS,Verified'
            ];

            results.naive.forEach(result => {
                csv.push(`${result.size},${result.workgroupSize},${result.time.toFixed(2)},${result.gflops.toFixed(2)},${result.verified}`);
            });

            const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', 'benchmark_results.csv');
            a.click();
        }

        // Update device info
        async function updateDeviceInfo() {
            const deviceInfoElement = document.getElementById("deviceInfo");
            try {
                if (!navigator.gpu) {
                    throw new Error("WebGPU not supported on this browser.");
                }
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error("No appropriate GPUAdapter found.");
                }
                const adapterInfo = await adapter.requestAdapterInfo();

                deviceInfoElement.innerHTML = `
                    <strong>GPU Vendor:</strong> ${adapterInfo.vendor}<br>
                    <strong>GPU Architecture:</strong> ${adapterInfo.architecture}<br>
                    <strong>Description:</strong> ${adapterInfo.description || 'Not available'}<br>
                    <strong>Device:</strong> ${navigator.platform}<br>
                    <strong>Browser:</strong> ${navigator.userAgent}
                `;
            } catch (error) {
                deviceInfoElement.innerHTML = `
                    <strong>Error:</strong> ${error.message}<br>
                    <strong>Device:</strong> ${navigator.platform}<br>
                    <strong>Browser:</strong> ${navigator.userAgent}
                `;
            }
        }

        // Initialize
        async function initialize() {
            try {
                await initWebGPU();
                await updateDeviceInfo();

                // Initialize matrix size checkboxes
                const sizesContainer = document.getElementById('sizeCheckboxes');
                sizesContainer.innerHTML = matrixSizes.map(size => `
                    <label>
                        <input type="checkbox" value="${size}" checked>
                        ${size}x${size}
                    </label>
                `).join(' ');

                // Initialize workgroup checkboxes
                const naiveWorkgroupsContainer = document.getElementById('naiveWorkgroups');
                naiveWorkgroupsContainer.innerHTML = naiveWorkgroupSizes.map(size => `
                    <label>
                        <input type="checkbox" value="${size}" ${size === '16,16' ? 'checked' : ''}>
                        ${size.replace(',', 'x')}
                    </label>
                `).join('');

                document.getElementById('generateMatrices').addEventListener('click', async () => {
                    const selectedSizes = Array.from(document.querySelectorAll('#sizeCheckboxes input:checked'))
                        .map(cb => parseInt(cb.value));
                    await generateMatrices(selectedSizes);
                    alert('Matrices generated successfully!');
                });

                document.getElementById('runBenchmark').addEventListener('click', performBenchmark);
                document.getElementById('downloadResults').addEventListener('click', downloadResults);

            } catch (error) {
                console.error('Initialization failed:', error);
                alert('Failed to initialize WebGPU: ' + error.message);
            }
        }

        window.addEventListener('load', initialize);
    </script>
</body>
</html>

