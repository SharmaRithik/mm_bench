
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Multiplication Benchmark</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .tile {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-container {
            height: 500px;
	    position: relative;
	    width: 100%;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
        }
        .matrix-sizes {
            margin: 10px 0;
        }
        .config-section {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .config-section h4 {
            margin-top: 0;
        }
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .options-grid label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            white-space: nowrap;
        }
        #sizeCheckboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        #sizeCheckboxes label {
            white-space: nowrap;
        }
        .button-group {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            margin-left: 16px;
        }
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .small-button {
            padding: 4px 8px;
            font-size: 12px;
            background-color: #6c757d;
        }
        .bar-charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            padding: 10px;
        }
        .bar-chart-wrapper {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            height: 400px;
        }
        .implementation-selector {
            margin: 10px 0;
        }
        .implementation-selector label {
            margin-right: 15px;
        }
        .tile-options {
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        .tile-options.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .tile-size-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }
        .performance-summary {
            overflow-x: auto;
        }
        
        #performanceSummaryTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        #performanceSummaryTable th,
        #performanceSummaryTable td {
            padding: 8px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        #performanceSummaryTable th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        #performanceSummaryTable tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        #performanceSummaryTable tr:hover {
            background-color: #f5f5f5;
        }
        
        .method-cell {
            font-weight: 500;
        }
        
        .time-cell {
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="tile">
            <h2>Matrix Multiplication Benchmark</h2>
            <div id="deviceInfo"></div>
        </div>
        
        <div class="tile">
            <h3>Configuration</h3>
            <div class="config-section">
                <div class="section-header">
                    <h4>Matrix Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleMatrixSizes('reset')">Reset</button>
                        <button class="small-button" onclick="handleMatrixSizes('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="sizeCheckboxes"></div>
            </div>
            
            <div class="config-section">
                <div class="section-header">
                    <h4>Workgroup Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleWorkgroups('reset')">Reset</button>
                        <button class="small-button" onclick="handleWorkgroups('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="workgroupSizes" class="options-grid"></div>
            </div>

            <div class="config-section">
                <div class="section-header">
                    <h4>Tile Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleTileSizes('reset')">Reset</button>
                        <button class="small-button" onclick="handleTileSizes('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="tileSizes" class="options-grid"></div>
            </div>

            <div class="config-section">
                <div class="section-header">
                    <h4>Kernels</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleKernels('reset')">Reset</button>
                        <button class="small-button" onclick="handleKernels('selectAll')">Select All</button>
                    </div>
                </div>
                <div class="implementation-selector">
                    <label>
                        <input type="checkbox" id="naiveImplementation">
                        Naive
                    </label>
                    <label>
                        <input type="checkbox" id="sharedMemoryImplementation">
                        Shared Memory Tiling
                    </label>
                    <label>
                        <input type="checkbox" id="vectorizedImplementation">
                        Vectorized
                    </label>
                    <label>
                        <input type="checkbox" id="coarsenedImplementation">
                        Coarsened
                    </label>
                    <label>
                        <input type="checkbox" id="oneDTilingImplementation">
                        1D Tiling
                    </label>
                </div>
            </div>

            <div class="config-section">
                <label for="iterations">Number of iterations:</label>
                <input type="number" id="iterations" value="1" min="1" max="100">
            </div>

            <div>
                <button id="generateMatrices">Generate Matrices</button>
                <button id="runBenchmark">Run Benchmark</button>
                <button id="downloadResults">Download Results</button>
            </div>
        </div>

        <div class="tile">
            <h3>Results</h3>
            <div id="resultsTable"></div>
        </div>

        <div class="tile">
            <h3>Performance Comparison</h3>
            <div class="chart-container">
                <canvas id="benchmarkChart"></canvas>
            </div>
        </div>

        <div class="tile">
            <h3>Performance by Matrix Size</h3>
            <div id="barChartsContainer" class="bar-charts-container">
            </div>
        </div>
        <div class="tile">
            <h3>Performance Summary</h3>
            <div class="performance-summary">
                <table id="performanceSummaryTable">
                    <thead>
                        <tr>
                            <th>Matrix Size</th>
                            <th colspan="2">Best Performance</th>
                            <th colspan="2">Second Best</th>
                            <th colspan="2">Third Best</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>

    // Configuration
    const matrixSizes = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];

    // Generate workgroup sizes based on the specified logic
    const workgroupSizes = [];
    for (let x = 0; x <= 8; x++) {
        for (let y = 0; y <= 8; y++) {
            const xDim = Math.pow(2, x);
            const yDim = Math.pow(2, y);
            if (xDim * yDim <= 256) {
                workgroupSizes.push(`${xDim},${yDim}`);
            }
        }
    }

    let device;
    let generatedMatrices = {};
    let benchmarkChart;
    let results = {
        naive: [],
        sharedMemory: [],
        vectorized: [],
	coarsened: [],
	oneDTiling: []
    };

    // Generate tile sizes for a given workgroup size
    function generateTileSizes(workgroupSize) {
        const [wx, wy] = workgroupSize.split(',').map(Number);
        const tileSizes = new Set();
        
        // Get maximum allowed power of 2 for each dimension
        const maxPowerX = Math.floor(Math.log2(wx));
        const maxPowerY = Math.floor(Math.log2(wy));
        
        // Generate all possible rectangular combinations
        for (let px = 0; px <= maxPowerX; px++) {
            for (let py = 0; py <= maxPowerY; py++) {
                const tileX = Math.pow(2, px);
                const tileY = Math.pow(2, py);
                
                // Add the rectangular tile size
                tileSizes.add(`${tileX},${tileY}`);
            }
        }
        
        return Array.from(tileSizes);
    }

    const coarseningSizes = [];
    for (let x = 0; x <= 4; x++) {
        for (let y = 0; y <= 4; y++) {
            const xDim = Math.pow(2, x);
            const yDim = Math.pow(2, y);
            coarseningSizes.push(`${xDim},${yDim}`);
        }
    }

    const tileMultiplierSizes = [];
    for (let x = 0; x <= 4; x++) { 
        tileMultiplierSizes.push(Math.pow(2, x));
    }

    // Update validation function for tile size compatibility
    function isTileSizeCompatibleWithWorkgroup(tileSize, workgroupSize) {
        const [tileWidth, tileHeight] = tileSize.split(',').map(Number);
        const [workgroupWidth, workgroupHeight] = workgroupSize.split(',').map(Number);
        
        // Each tile dimension must fit within its corresponding workgroup dimension
        return tileWidth <= workgroupWidth && tileHeight <= workgroupHeight;
    }

    // Update tile size options based on selected workgroup
    function updateTileSizes() {
        const selectedWorkgroups = Array.from(document.querySelectorAll('#workgroupSizes input:checked'))
            .map(cb => cb.value);

        const tileSizesContainer = document.getElementById('tileSizes');
        const allTileSizes = new Set();

        selectedWorkgroups.forEach(workgroupSize => {
            generateTileSizes(workgroupSize).forEach(size => allTileSizes.add(size));
        });

        tileSizesContainer.innerHTML = Array.from(allTileSizes).sort((a, b) => {
            const [aSize] = a.split(',').map(Number);
            const [bSize] = b.split(',').map(Number);
            return aSize - bSize;
        }).map(size => `
            <label>
                <input type="checkbox" value="${size}" ${size === '16,16' ? 'checked' : ''}>
                ${size.replace(',', 'x')}
            </label>
        `).join('');
    }

    function handleKernels(action) {
        const checkboxes = document.querySelectorAll('.implementation-selector input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            if (action === 'selectAll') {
                checkbox.checked = true;
            } else if (action === 'reset') {
                // Set default state
                checkbox.checked = [].includes(checkbox.id);
            }
        });
    }

    // Naive WGSL implementation
    function getNaiveWGSL(workgroupSize) {
        const [wx, wy] = workgroupSize.split(',').map(Number);
        return `
            @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
            @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
            @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
            @group(0) @binding(3) var<uniform> uniforms : Uniforms;

            struct Uniforms {
                N : u32,
                alpha : f32,
                beta : f32,
            }

            @compute @workgroup_size(${wx}, ${wy})
            fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                let N = uniforms.N;
                let row = global_id.y;
                let col = global_id.x;

                if (row >= N || col >= N) {
                    return;
                }

                let row_offset = row * N;
                var sum: f32 = 0.0;

                for (var k = 0u; k < N; k = k + 1u) {
                    let a = matrixA[row_offset + k];
                    let b = matrixB[k * N + col];
                    sum = sum + a * b;
                }

                matrixC[row_offset + col] = uniforms.alpha * sum + uniforms.beta * matrixC[row_offset + col];
            }
        `;
    }

    // Shared Memory Tiling WGSL implementation
    function getNaiveDecoupledSharedMemoryWGSL(workgroupSize, tileSize) {
        const [THREADS_X, THREADS_Y] = workgroupSize.split(',').map(Number);
        const [TUNE_SPLIT, _] = tileSize.split(',').map(Number);
        
        return `
            @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
            @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
            @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
            @group(0) @binding(3) var<uniform> uniforms : Uniforms;
    
            struct Uniforms {
                N : u32,
                alpha : f32,
                beta : f32,
            }
    
            const THREADS_X = ${THREADS_X}u;
            const THREADS_Y = ${THREADS_Y}u;
            const TUNE_SPLIT = ${TUNE_SPLIT}u;
    
            fn index2D(row: u32, col: u32, stride: u32) -> u32 {
                return row * stride + col;
            }
    
            var<workgroup> A_shared: array<f32, ${THREADS_Y * TUNE_SPLIT}>;
            var<workgroup> B_shared: array<f32, ${TUNE_SPLIT * THREADS_X}>;
    
            @compute @workgroup_size(${THREADS_X}, ${THREADS_Y})
            fn main(
                @builtin(global_invocation_id) global_id: vec3<u32>,
                @builtin(local_invocation_id) local_id: vec3<u32>,
                @builtin(workgroup_id) workgroup_id: vec3<u32>
            ) {
                let N = uniforms.N;
                let i = global_id.y;
                let j = global_id.x;
                let local_i = local_id.y;
                let local_j = local_id.x;
                
                var value: f32 = 0.0;
                
                for (var outer_k: u32 = 0u; outer_k < N; outer_k += TUNE_SPLIT) {
                    // Cache data from global memory to shared memory for A
                    for (var local_j_stride = local_j; 
                         local_j_stride < TUNE_SPLIT; 
                         local_j_stride += THREADS_X) {
                        let shared_idx = index2D(local_i, local_j_stride, TUNE_SPLIT);
                        let global_idx = index2D(i, outer_k + local_j_stride, N);
                        
                        var data_a = 0.0;
                        if (i < N && (outer_k + local_j_stride) < N) {
                            data_a = matrixA[global_idx];
                        }
                        A_shared[shared_idx] = data_a;
                    }
                    
                    // Cache data from global memory to shared memory for B
                    for (var local_i_stride = local_i; 
                         local_i_stride < TUNE_SPLIT; 
                         local_i_stride += THREADS_Y) {
                        let shared_idx = index2D(local_i_stride, local_j, THREADS_X);
                        let global_idx = index2D(outer_k + local_i_stride, j, N);
                        
                        var data_b = 0.0;
                        if ((outer_k + local_i_stride) < N && j < N) {
                            data_b = matrixB[global_idx];
                        }
                        B_shared[shared_idx] = data_b;
                    }
                    
                    // Synchronize all threads in the workgroup
                    workgroupBarrier();
                    
                    // Compute partial results using shared memory
                    if (i < N && j < N) {
                        for (var inner_k: u32 = 0u; inner_k < TUNE_SPLIT; inner_k = inner_k + 1u) {
                            if (outer_k + inner_k < N) {
                                let a_idx = index2D(local_i, inner_k, TUNE_SPLIT);
                                let b_idx = index2D(inner_k, local_j, THREADS_X);
                                value = value + A_shared[a_idx] * B_shared[b_idx];
                            }
                        }
                    }
                    
                    // Synchronize before next iteration
                    workgroupBarrier();
                }
                
                // Write final result
                if (i < N && j < N) {
                    let result_idx = index2D(i, j, N);
                    matrixC[result_idx] = uniforms.alpha * value + uniforms.beta * matrixC[result_idx];
                }
            }
        `;
    }

    // Vectorized Shared Memory WGSL implementation
    function getVectorizedSharedMemoryWGSL(workgroupSize, tileSize) {
        const [THREADS_X, THREADS_Y] = workgroupSize.split(',').map(Number);
        const [TUNE_SPLIT, _] = tileSize.split(',').map(Number);
        
        // Ensure TILE_SIZE >= 4
        if (TUNE_SPLIT < 4) {
            throw new Error("TILE_SIZE must be >= 4 for vectorization");
        }
    
        return `
            @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
            @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
            @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
            @group(0) @binding(3) var<uniform> uniforms : Uniforms;
            
            struct Uniforms {
                N : u32,
                alpha : f32,
                beta : f32,
            }
            
            const THREADS_X = ${THREADS_X}u;
            const THREADS_Y = ${THREADS_Y}u;
            const TUNE_SPLIT = ${TUNE_SPLIT}u;
            const VEC_SIZE = 4u;  // Using vec4 for vectorization
            
            fn index2D(row: u32, col: u32, stride: u32) -> u32 {
                return row * stride + col;
            }
            
            var<workgroup> A_shared: array<f32, ${THREADS_Y * TUNE_SPLIT}>;
            var<workgroup> B_shared: array<f32, ${TUNE_SPLIT * THREADS_X}>;
            
            @compute @workgroup_size(${THREADS_X}, ${THREADS_Y})
            fn main(
                @builtin(global_invocation_id) global_id: vec3<u32>,
                @builtin(local_invocation_id) local_id: vec3<u32>,
                @builtin(workgroup_id) workgroup_id: vec3<u32>
            ) {
                let N = uniforms.N;
                let i = global_id.y;
                let j = global_id.x;
                let local_i = local_id.y;
                let local_j = local_id.x;
                
                var acc_value = 0.0;
                
                for (var outer_k: u32 = 0u; outer_k < N; outer_k += TUNE_SPLIT) {
                    // Cache data from global memory to shared memory for A
                    for (var local_j_stride = local_j; local_j_stride < TUNE_SPLIT; local_j_stride += THREADS_X) {
                        let shared_idx = index2D(local_i, local_j_stride, TUNE_SPLIT);
                        let global_idx = index2D(i, outer_k + local_j_stride, N);
                        
                        var data_a = 0.0;
                        if (i < N && (outer_k + local_j_stride) < N) {
                            data_a = matrixA[global_idx];
                        }
                        A_shared[shared_idx] = data_a;
                    }
                    
                    // Cache data from global memory to shared memory for B
                    for (var local_i_stride = local_i; local_i_stride < TUNE_SPLIT; local_i_stride += THREADS_Y) {
                        let shared_idx = index2D(local_i_stride, local_j, THREADS_X);
                        let global_idx = index2D(outer_k + local_i_stride, j, N);
                        
                        var data_b = 0.0;
                        if ((outer_k + local_i_stride) < N && j < N) {
                            data_b = matrixB[global_idx];
                        }
                        B_shared[shared_idx] = data_b;
                    }
                    
                    workgroupBarrier();
                    
                    // Vectorized computation using dot product
                    if (i < N && j < N) {
                        for (var inner_k: u32 = 0u; inner_k < TUNE_SPLIT; inner_k += VEC_SIZE) {
                            if (outer_k + inner_k + 3u < N) {
                                let a_idx = index2D(local_i, inner_k, TUNE_SPLIT);
                                let b_idx = index2D(inner_k, local_j, THREADS_X);
                                
                                let a_vec = vec4<f32>(
                                    A_shared[a_idx],
                                    A_shared[a_idx + 1u],
                                    A_shared[a_idx + 2u],
                                    A_shared[a_idx + 3u]
                                );
                                
                                let b_vec = vec4<f32>(
                                    B_shared[b_idx],
                                    B_shared[b_idx + THREADS_X],
                                    B_shared[b_idx + 2u * THREADS_X],
                                    B_shared[b_idx + 3u * THREADS_X]
                                );
                                
                                // Use dot product instead of manual multiplication and addition
                                acc_value = acc_value + dot(a_vec, b_vec);
                            }
                        }
                    }
                    
                    workgroupBarrier();
                }
                
                // Write final result
                if (i < N && j < N) {
                    let result_idx = index2D(i, j, N);
                    matrixC[result_idx] = uniforms.alpha * acc_value + uniforms.beta * matrixC[result_idx];
                }
            }
    `;}

    function getCoarsenedSharedMemoryWGSL(workgroupSize, tileSize, coarsenX, coarsenY) {
        const [THREADS_X, THREADS_Y] = workgroupSize.split(',').map(Number);
        const [TUNE_SPLIT, _] = tileSize.split(',').map(Number);
        
        return `
            @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
            @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
            @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
            @group(0) @binding(3) var<uniform> uniforms : Uniforms;
    
            struct Uniforms {
                N : u32,
                alpha : f32,
                beta : f32,
            }
    
            const THREADS_X = ${THREADS_X}u;
            const THREADS_Y = ${THREADS_Y}u;
            const TUNE_SPLIT = ${TUNE_SPLIT}u;
            const COARSEN_X = ${coarsenX}u;
            const COARSEN_Y = ${coarsenY}u;
    
            fn index2D(row: u32, col: u32, stride: u32) -> u32 {
                return row * stride + col;
            }
    
            var<workgroup> A_shared: array<f32, ${THREADS_Y * TUNE_SPLIT * coarsenY}>;
            var<workgroup> B_shared: array<f32, ${TUNE_SPLIT * THREADS_X * coarsenX}>;
    
            @compute @workgroup_size(${THREADS_X}, ${THREADS_Y})
            fn main(
                @builtin(global_invocation_id) global_id: vec3<u32>,
                @builtin(local_invocation_id) local_id: vec3<u32>,
                @builtin(workgroup_id) workgroup_id: vec3<u32>
            ) {
                let N = uniforms.N;
                
                // Calculate base indices for the block of elements this thread will compute
                let base_global_row = workgroup_id.y * (THREADS_Y * COARSEN_Y) + local_id.y;
                let base_global_col = workgroup_id.x * (THREADS_X * COARSEN_X) + local_id.x;
    
                // Initialize accumulators
                var acc: array<array<f32, ${coarsenX}>, ${coarsenY}>;
                for (var cy = 0u; cy < COARSEN_Y; cy = cy + 1u) {
                    for (var cx = 0u; cx < COARSEN_X; cx = cx + 1u) {
                        acc[cy][cx] = 0.0;
                    }
                }
    
                // Process tiles
                for (var tile_idx = 0u; tile_idx < N; tile_idx += TUNE_SPLIT) {
                    // Load A tiles into shared memory
                    for (var cy = 0u; cy < COARSEN_Y; cy = cy + 1u) {
                        let row = base_global_row + cy * THREADS_Y;
                        if (row < N) {
                            for (var k = local_id.x; k < TUNE_SPLIT; k += THREADS_X) {
                                let global_idx = index2D(row, tile_idx + k, N);
                                let shared_idx = index2D(local_id.y + cy * THREADS_Y, k, TUNE_SPLIT);
                                A_shared[shared_idx] = select(0.0, matrixA[global_idx], tile_idx + k < N);
                            }
                        }
                    }
    
                    // Load B tiles into shared memory
                    for (var cx = 0u; cx < COARSEN_X; cx = cx + 1u) {
                        let col = base_global_col + cx * THREADS_X;
                        if (col < N) {
                            for (var k = local_id.y; k < TUNE_SPLIT; k += THREADS_Y) {
                                let global_idx = index2D(tile_idx + k, col, N);
                                let shared_idx = index2D(k, local_id.x + cx * THREADS_X, THREADS_X * COARSEN_X);
                                B_shared[shared_idx] = select(0.0, matrixB[global_idx], tile_idx + k < N);
                            }
                        }
                    }
    
                    workgroupBarrier();
    
                    // Compute partial results
                    for (var k = 0u; k < TUNE_SPLIT; k = k + 1u) {
                        for (var cy = 0u; cy < COARSEN_Y; cy = cy + 1u) {
                            let row = base_global_row + cy * THREADS_Y;
                            if (row >= N) { continue; }
                            
                            let a_val = A_shared[index2D(local_id.y + cy * THREADS_Y, k, TUNE_SPLIT)];
                            
                            for (var cx = 0u; cx < COARSEN_X; cx = cx + 1u) {
                                let col = base_global_col + cx * THREADS_X;
                                if (col >= N) { continue; }
                                
                                let b_val = B_shared[index2D(k, local_id.x + cx * THREADS_X, THREADS_X * COARSEN_X)];
                                acc[cy][cx] = acc[cy][cx] + a_val * b_val;
                            }
                        }
                    }
    
                    workgroupBarrier();
                }
    
                // Write results
                for (var cy = 0u; cy < COARSEN_Y; cy = cy + 1u) {
                    let row = base_global_row + cy * THREADS_Y;
                    if (row >= N) { continue; }
    
                    for (var cx = 0u; cx < COARSEN_X; cx = cx + 1u) {
                        let col = base_global_col + cx * THREADS_X;
                        if (col >= N) { continue; }
    
                        let idx = index2D(row, col, N);
                        matrixC[idx] = uniforms.alpha * acc[cy][cx] + uniforms.beta * matrixC[idx];
                    }
                }
            }
        `;
    }

    function get1DSharedMemoryTilingWGSL(workgroupSize, tilingMultiplier) {
        const [THREADS_X, THREADS_Y] = workgroupSize.split(',').map(Number);
        const TM = Number(tilingMultiplier);
        const TILE_X = THREADS_X;
        const TILE_Y = THREADS_Y * TM;
    
        return `
            @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
            @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
            @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
            @group(0) @binding(3) var<uniform> uniforms : Uniforms;
    
            struct Uniforms {
                N : u32,
                alpha : f32,
                beta : f32,
            }
    
            const THREADS_X = ${THREADS_X}u;
            const THREADS_Y = ${THREADS_Y}u;
            const TM = ${TM}u;
            const TILE_X = THREADS_X;
            const TILE_Y = THREADS_Y * TM;
    
            // Double buffering for shared memory with padding to avoid bank conflicts
            var<workgroup> A_buffer1: array<f32, ${THREADS_X * THREADS_Y * TM + THREADS_X}>;
            var<workgroup> A_buffer2: array<f32, ${THREADS_X * THREADS_Y * TM + THREADS_X}>;
            var<workgroup> B_buffer1: array<f32, ${TILE_X * TILE_X + THREADS_X}>;
            var<workgroup> B_buffer2: array<f32, ${TILE_X * TILE_X + THREADS_X}>;
    
            fn index1D(row: u32, col: u32, stride: u32) -> u32 {
                return row * (stride + 1u) + col; // Added padding for bank conflict avoidance
            }
    
            @compute @workgroup_size(${THREADS_X}, ${THREADS_Y})
            fn main(
                @builtin(global_invocation_id) global_id: vec3<u32>,
                @builtin(local_invocation_id) local_id: vec3<u32>,
                @builtin(workgroup_id) workgroup_id: vec3<u32>
            ) {
                let N = uniforms.N;
                let wg_row = workgroup_id.y;
                let wg_col = workgroup_id.x;
                let local_row = local_id.y;
                let local_col = local_id.x;
    
                // Thread accumulation registers
                var thread_results: array<f32, ${TM}>;
                for (var t = 0u; t < TM; t = t + 1u) {
                    thread_results[t] = 0.0;
                }
                
                // Main computation loop with double buffering
                var buffer_idx = 0u;
                for (var tile = 0u; tile < N; tile = tile + TILE_X) {
                    let a_shared_base_idx = (local_row * TM) * TILE_X + local_col;
                    let b_shared_idx = index1D(local_row, local_col, TILE_X);
    
                    // Load current tile
                    for (var extra = 0u; extra < TM; extra = extra + 1u) {
                        let global_row = wg_row * TILE_Y + (local_row * TM) + extra;
                        let global_col = tile + local_col;
                        let current_idx = index1D(local_row * TM + extra, local_col, TILE_X);
    
                        if (global_row < N && global_col < N) {
                            if (buffer_idx == 0u) {
                                A_buffer1[current_idx] = matrixA[global_row * N + global_col];
                            } else {
                                A_buffer2[current_idx] = matrixA[global_row * N + global_col];
                            }
                        } else {
                            if (buffer_idx == 0u) {
                                A_buffer1[current_idx] = 0.0;
                            } else {
                                A_buffer2[current_idx] = 0.0;
                            }
                        }
                    }
    
                    // Load B matrix tile
                    let b_global_row = tile + local_row;
                    let b_global_col = wg_col * TILE_X + local_col;
                    
                    if (b_global_row < N && b_global_col < N) {
                        if (buffer_idx == 0u) {
                            B_buffer1[b_shared_idx] = matrixB[b_global_row * N + b_global_col];
                        } else {
                            B_buffer2[b_shared_idx] = matrixB[b_global_row * N + b_global_col];
                        }
                    } else {
                        if (buffer_idx == 0u) {
                            B_buffer1[b_shared_idx] = 0.0;
                        } else {
                            B_buffer2[b_shared_idx] = 0.0;
                        }
                    }
    
                    workgroupBarrier();
    
                    // Compute using current tile
                    for (var k = 0u; k < TILE_X; k = k + 1u) {
                        let k_idx = index1D(k, local_col, TILE_X);
                        let b_val = select(B_buffer2[k_idx], B_buffer1[k_idx], buffer_idx == 0u);
                        
                        for (var t = 0u; t < TM; t = t + 1u) {
                            let a_idx = index1D(local_row * TM + t, k, TILE_X);
                            let a_val = select(A_buffer2[a_idx], A_buffer1[a_idx], buffer_idx == 0u);
                            thread_results[t] += a_val * b_val;
                        }
                    }
    
                    workgroupBarrier();
                    buffer_idx = 1u - buffer_idx;  // Toggle between 0 and 1
                }
    
                // Write results to global memory
                for (var t = 0u; t < TM; t = t + 1u) {
                    let global_row = wg_row * TILE_Y + local_row * TM + t;
                    let global_col = wg_col * TILE_X + local_col;
    
                    if (global_row < N && global_col < N) {
                        let idx = global_row * N + global_col;
                        matrixC[idx] = uniforms.alpha * thread_results[t] + uniforms.beta * matrixC[idx];
                    }
                }
            }
        `;
    }

    // Initialize WebGPU
    async function initWebGPU() {
        if (!navigator.gpu) {
            throw new Error("WebGPU not supported");
        }
        const adapter = await navigator.gpu.requestAdapter();
        device = await adapter.requestDevice();
        return device;
    }
			    
    // Create buffer helper function
    function createBuffer(data, usage) {
        const buffer = device.createBuffer({
            size: data.byteLength,
            usage: usage,
            mappedAtCreation: true,
        });
        new Float32Array(buffer.getMappedRange()).set(data);
        buffer.unmap();
        return buffer;
    }

    function updateChart() {
        const ctx = document.getElementById('benchmarkChart').getContext('2d');
    
        if (benchmarkChart) {
            benchmarkChart.destroy();
        }
    
        const colors = [
            'rgb(54, 162, 235)',  // blue
            'rgb(75, 192, 192)',  // teal
            'rgb(153, 102, 255)', // purple
            'rgb(255, 159, 64)',  // orange
            'rgb(255, 99, 132)'   // red
        ];
    
        function formatConfigForLegend(result) {
            let config = `${result.implementation} (${result.workgroupSize.replace(',', 'x')})`;
            if (result.implementation === '1D Tiling') {
                if (result.tilingMultiplier) {
                    config += ` TM${result.tilingMultiplier}x`;
                }
            } else {
                if (result.tileSize && result.tileSize !== 'N/A') {
                    config += ` T${result.tileSize.replace(',', 'x')}`;
                }
                if (result.coarsenX && result.coarsenY) {
                    config += ` C${result.coarsenX}x${result.coarsenY}`;
                }
            }
            return config;
        }
    
        // Get all matrix sizes
        const matrixSizes = [...new Set([
            ...results.naive.map(r => r.size),
            ...results.sharedMemory.map(r => r.size),
            ...results.vectorized.map(r => r.size),
            ...results.coarsened.map(r => r.size),
            ...results.oneDTiling.map(r => r.size)
        ])].sort((a, b) => a - b);
    
        // Track top configurations and their performance
        const trackedConfigs = new Map();
    
        // For each size, identify and track the top 3 configurations
        matrixSizes.forEach(size => {
            const sizeResults = [
                ...results.naive.filter(r => r.verified && r.size === size),
                ...results.sharedMemory.filter(r => r.verified && r.size === size),
                ...results.vectorized.filter(r => r.verified && r.size === size),
                ...results.coarsened.filter(r => r.verified && r.size === size),
                ...results.oneDTiling.filter(r => r.verified && r.size === size)
            ].sort((a, b) => a.time - b.time);
    
            // Take top 3 for this size
            const top3 = sizeResults.slice(0, 3);
            
            top3.forEach(result => {
                const configKey = formatConfigForLegend(result);
                if (!trackedConfigs.has(configKey)) {
                    trackedConfigs.set(configKey, {
                        label: configKey,
                        data: [],
                        firstSeenAtSize: size,
                        implementation: result.implementation,
                        workgroupSize: result.workgroupSize,
                        tileSize: result.tileSize,
                        coarsenX: result.coarsenX,
                        coarsenY: result.coarsenY,
                        tilingMultiplier: result.tilingMultiplier
                    });
                }
            });
        });
    
        // Now collect all performance data for tracked configurations
        trackedConfigs.forEach((config, configKey) => {
            matrixSizes.forEach(size => {
                // Only collect data for sizes >= when config first appeared as top 3
                if (size >= config.firstSeenAtSize) {
                    let result;
                    switch (config.implementation) {
                        case 'Naive':
                            result = results.naive.find(r => 
                                r.verified && 
                                r.size === size && 
                                r.workgroupSize === config.workgroupSize
                            );
                            break;
                        case 'Shared Memory':
                            result = results.sharedMemory.find(r => 
                                r.verified && 
                                r.size === size && 
                                r.workgroupSize === config.workgroupSize && 
                                r.tileSize === config.tileSize
                            );
                            break;
                        case 'Vectorized':
                            result = results.vectorized.find(r => 
                                r.verified && 
                                r.size === size && 
                                r.workgroupSize === config.workgroupSize && 
                                r.tileSize === config.tileSize
                            );
                            break;
                        case 'Coarsened':
                            result = results.coarsened.find(r => 
                                r.verified && 
                                r.size === size && 
                                r.workgroupSize === config.workgroupSize && 
                                r.tileSize === config.tileSize &&
                                r.coarsenX === config.coarsenX &&
                                r.coarsenY === config.coarsenY
                            );
                            break;
                        case '1D Tiling':
                            result = results.oneDTiling.find(r => 
                                r.verified && 
                                r.size === size && 
                                r.workgroupSize === config.workgroupSize && 
                                r.tilingMultiplier === config.tilingMultiplier
                            );
                            break;
                    }
                    if (result) {
                        config.data.push({
                            x: size,
                            y: result.time
                        });
                    }
                }
            });
        });
    
        // Create datasets from tracked configurations
        const datasets = Array.from(trackedConfigs.values())
            .map((config, index) => ({
                label: config.label,
                data: config.data,
                borderColor: colors[index % colors.length],
                backgroundColor: colors[index % colors.length].replace('rgb', 'rgba').replace(')', ', 0.1)'),
                tension: 0.1,
                fill: false
            }))
            .sort((a, b) => {
                // Sort by performance at last measured point
                const aLastValue = a.data[a.data.length - 1]?.y || Infinity;
                const bLastValue = b.data[b.data.length - 1]?.y || Infinity;
                return aLastValue - bLastValue;
            });
    
        benchmarkChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: matrixSizes.map(size => `${size}x${size}`),
                datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'category',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: 'Matrix Size',
                            padding: 10
                        },
                        ticks: {
                            autoSkip: false
                        }
                    },
                    y: {
                        type: 'logarithmic',
                        title: {
                            display: true,
                            text: 'Time (ms)',
                            padding: 10
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Top Performing Kernel Configurations',
                        padding: {
                            top: 10,
                            bottom: 20
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} ms`;
                            }
                        }
                    },
                    legend: {
                        position: 'bottom',
                        labels: {
                            boxWidth: 12,
                            padding: 15,
                            font: {
                                size: 11
                            }
                        }
                    }
                },
                layout: {
                    padding: {
                        top: 10,
                        right: 20,
                        bottom: 20,
                        left: 10
                    }
                }
            }
        });
    }

    function createBarCharts() {
        const barChartsContainer = document.getElementById('barChartsContainer');
        barChartsContainer.innerHTML = '';
    
        const verifiedResults = [
            ...results.naive.filter(r => r.verified),
            ...results.sharedMemory.filter(r => r.verified),
            ...results.vectorized.filter(r => r.verified),
            ...results.coarsened.filter(r => r.verified),
            ...results.oneDTiling.filter(r => r.verified)
        ];
    
        const getImplementationColor = (implementation, alpha = 0.8) => {
            const colors = {
                'Naive': `rgba(255, 99, 132, ${alpha})`,
                'Shared Memory': `rgba(54, 162, 235, ${alpha})`,
                'Vectorized': `rgba(75, 192, 192, ${alpha})`,
                'Coarsened': `rgba(153, 102, 255, ${alpha})`,
                '1D Tiling': `rgba(255, 159, 64, ${alpha})`
            };
            return colors[implementation] || `rgba(201, 203, 207, ${alpha})`;
        };
    
        const matrixSizes = [...new Set(verifiedResults.map(r => r.size))]
            .sort((a, b) => a - b);
    
        matrixSizes.forEach(size => {
            const sizeResults = verifiedResults
                .filter(r => r.size === size)
                .sort((a, b) => a.time - b.time);
    
            if (sizeResults.length === 0) return;
    
            const chartWrapper = document.createElement('div');
            chartWrapper.className = 'bar-chart-wrapper';
            const canvas = document.createElement('canvas');
            chartWrapper.appendChild(canvas);
            barChartsContainer.appendChild(chartWrapper);
    
            const maxTime = Math.max(...sizeResults.map(r => r.time));
            const yAxisMax = Math.ceil(maxTime * 1.1);
    
            const getConfigLabel = (result) => {
                const implementation = result.implementation;
                const workgroupSize = result.workgroupSize.replace(',', 'x');
                let configDetails = '';
    
                if (result.tileSize && result.tileSize !== 'N/A') {
                    configDetails += ` Tile(${result.tileSize.replace(',', 'x')})`;
                }
                if (result.coarsenX && result.coarsenY) {
                    configDetails += ` Coarse(${result.coarsenX}x${result.coarsenY})`;
                }
                if (result.tilingMultiplier) {
                    configDetails += ` TM(${result.tilingMultiplier}x)`;
                }
                
                return `${implementation} ${workgroupSize}${configDetails}`;
            };
    
            new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: sizeResults.map(r => getConfigLabel(r)),
                    datasets: [{
                        label: 'Execution Time',
                        data: sizeResults.map(r => r.time),
                        backgroundColor: sizeResults.map(r => getImplementationColor(r.implementation, 0.8)),
                        borderColor: sizeResults.map(r => getImplementationColor(r.implementation, 1)),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Performance for ${size}x${size} Matrix`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        subtitle: {
                            display: true,
                            text: 'Lower time is better',
                            padding: 10
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const result = sizeResults[context.dataIndex];
                                    let label = `Time: ${context.raw.toFixed(2)} ms`;
                                    if (result.gflops) {
                                        label += `\nGFLOPS: ${result.gflops.toFixed(2)}`;
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: yAxisMax,
                            title: {
                                display: true,
                                text: 'Time (ms)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Method & Configuration'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                }
            });
        });
    }

    function updatePerformanceSummary() {
        const matrixSizes = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
        const tbody = document.querySelector('#performanceSummaryTable tbody');
        tbody.innerHTML = '';
    
        matrixSizes.forEach(size => {
            // Collect all results for this size
            const sizeResults = [
                ...results.naive.filter(r => r.verified && r.size === size),
                ...results.sharedMemory.filter(r => r.verified && r.size === size),
                ...results.vectorized.filter(r => r.verified && r.size === size),
                ...results.coarsened.filter(r => r.verified && r.size === size),
                ...results.oneDTiling.filter(r => r.verified && r.size === size)
            ].sort((a, b) => a.time - b.time);
    
            if (sizeResults.length === 0) return;
    
            const row = document.createElement('tr');
                
            // Matrix size cell
            const sizeCell = document.createElement('td');
            sizeCell.textContent = `${size}x${size}`;
            row.appendChild(sizeCell);
    
            // Function to format the method description
            function formatMethodDescription(result) {
                let desc = result.implementation;
                desc += ` (${result.workgroupSize.replace(',', 'x')})`;
                
                if (result.implementation === '1D Tiling') {
                    if (result.tilingMultiplier) {
                        desc += ` TM(${result.tilingMultiplier}x)`;
                    }
                } else {
                    if (result.tileSize && result.tileSize !== 'N/A') {
                        desc += ` Tile(${result.tileSize.replace(',', 'x')})`;
                    }
                    if (result.coarsenX && result.coarsenY) {
                        desc += ` Coarse(${result.coarsenX}x${result.coarsenY})`;
                    }
                }
                return desc;
            }
    
            // Add top 3 performers
            for (let i = 0; i < 3; i++) {
                if (i < sizeResults.length) {
                    const result = sizeResults[i];
                    
                    // Method cell
                    const methodCell = document.createElement('td');
                    methodCell.className = 'method-cell';
                    methodCell.textContent = formatMethodDescription(result);
                    row.appendChild(methodCell);
    
                    // Time cell
                    const timeCell = document.createElement('td');
                    timeCell.className = 'time-cell';
                    timeCell.textContent = `${result.time.toFixed(2)} ms`;
                    row.appendChild(timeCell);
                } else {
                    // Empty cells if no result
                    const methodCell = document.createElement('td');
                    methodCell.className = 'method-cell';
                    methodCell.textContent = 'N/A';
                    row.appendChild(methodCell);
    
                    const timeCell = document.createElement('td');
                    timeCell.className = 'time-cell';
                    timeCell.textContent = 'N/A';
                    row.appendChild(timeCell);
                }
            }
    
            tbody.appendChild(row);
        });
    }
	
    // Generate matrices
    async function generateMatrices(sizes) {
        for (const N of sizes) {
            const matrixSize = N * N;
            const matrixA = new Float32Array(matrixSize);
            const matrixB = new Float32Array(matrixSize);

            for (let i = 0; i < matrixSize; i++) {
                matrixA[i] = Math.random();
                matrixB[i] = Math.random();
            }

            const bufferA = createBuffer(matrixA, GPUBufferUsage.STORAGE);
            const bufferB = createBuffer(matrixB, GPUBufferUsage.STORAGE);

            generatedMatrices[N] = { bufferA, bufferB, matrixA, matrixB };
        }
    }

    // Verify matrix multiplication
    function verifyMatrixMultiplication(matrixA, matrixB, resultMatrix, N, alpha, beta) {
        for (let check = 0; check < 5; check++) {
            const row = Math.floor(Math.random() * N);
            const col = Math.floor(Math.random() * N);
            let expected = 0;
            for (let i = 0; i < N; i++) {
                expected += matrixA[row * N + i] * matrixB[i * N + col];
            }
            expected = alpha * expected + beta * 0;
            const actual = resultMatrix[row * N + col];
            const relativeError = Math.abs((expected - actual) / expected);
            if (relativeError > 1e-5) {
                return false;
            }
        }
        return true;
    }

    // Run benchmark
    async function runBenchmark(N, workgroupSize, implementation = 'naive', tileSize = null, coarsenX = null, coarsenY = null, tilingMultiplier = null) {
        let shaderCode;
        switch(implementation) {
            case 'naive':
                shaderCode = getNaiveWGSL(workgroupSize);
                break;
            case 'shared':
                shaderCode = getNaiveDecoupledSharedMemoryWGSL(workgroupSize, tileSize);
                break;
            case 'vectorized':
                shaderCode = getVectorizedSharedMemoryWGSL(workgroupSize, tileSize);
                break;
            case 'coarsened':
                shaderCode = getCoarsenedSharedMemoryWGSL(workgroupSize, tileSize, coarsenX, coarsenY);
                break;
            case '1dtiling':
                shaderCode = get1DSharedMemoryTilingWGSL(workgroupSize, tilingMultiplier);  // Fixed this line
                break;
            default:
                throw new Error('Unknown implementation');
        }

        const shaderModule = device.createShaderModule({
            code: shaderCode
        });

        const { bufferA, bufferB, matrixA, matrixB } = generatedMatrices[N];
        const matrixSize = N * N;
        const resultMatrix = new Float32Array(matrixSize).fill(0);
        const bufferC = createBuffer(resultMatrix, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);

        const uniformBuffer = device.createBuffer({
            size: 16,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const uniformData = new ArrayBuffer(16);
        new Uint32Array(uniformData, 0, 1)[0] = N;
        new Float32Array(uniformData, 4, 1)[0] = 1.0;
        new Float32Array(uniformData, 8, 1)[0] = 0.0;
        device.queue.writeBuffer(uniformBuffer, 0, uniformData);

        const bindGroupLayout = device.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
            ],
        });

        const bindGroup = device.createBindGroup({
            layout: bindGroupLayout,
            entries: [
                { binding: 0, resource: { buffer: bufferA } },
                { binding: 1, resource: { buffer: bufferB } },
                { binding: 2, resource: { buffer: bufferC } },
                { binding: 3, resource: { buffer: uniformBuffer } },
            ],
        });

        const pipeline = device.createComputePipeline({
            layout: device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout],
            }),
            compute: {
                module: shaderModule,
                entryPoint: "main",
            },
        });

        const [wx, wy] = workgroupSize.split(',').map(Number);
        const commandEncoder = device.createCommandEncoder();
        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.dispatchWorkgroups(Math.ceil(N / wx), Math.ceil(N / wy));
        passEncoder.end();

        const startTime = performance.now();
        device.queue.submit([commandEncoder.finish()]);
        await device.queue.onSubmittedWorkDone();
        const endTime = performance.now();

        const resultReadBuffer = device.createBuffer({
            size: bufferC.size,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        });

        const readbackEncoder = device.createCommandEncoder();
        readbackEncoder.copyBufferToBuffer(bufferC, 0, resultReadBuffer, 0, bufferC.size);
        device.queue.submit([readbackEncoder.finish()]);

        await resultReadBuffer.mapAsync(GPUMapMode.READ);
        const resultArray = new Float32Array(resultReadBuffer.getMappedRange());
        const isVerified = verifyMatrixMultiplication(matrixA, matrixB, resultArray, N, 1.0, 0.0);
        resultReadBuffer.unmap();

        return {
            time: endTime - startTime,
            verified: isVerified
        };
    }

    // Perform benchmark with validation
    async function performBenchmark() {
        const iterations = parseInt(document.getElementById('iterations').value);
        const selectedSizes = Array.from(document.querySelectorAll('#sizeCheckboxes input:checked'))
            .map(cb => parseInt(cb.value));

        const selectedWorkgroups = Array.from(document.querySelectorAll('#workgroupSizes input:checked'))
            .map(cb => cb.value);

        const selectedTileSizes = Array.from(document.querySelectorAll('#tileSizes input:checked'))
            .map(cb => cb.value);

        const selectedCoarseningSizes = Array.from(document.querySelectorAll('#coarseningSizes input:checked'))
            .map(cb => cb.value);

        const selectedTileMultipliers = Array.from(document.querySelectorAll('#tileMultiplierSizes input:checked'))
            .map(cb => parseInt(cb.value));

        const runNaive = document.getElementById('naiveImplementation').checked;
        const runSharedMemory = document.getElementById('sharedMemoryImplementation').checked;
        const runVectorized = document.getElementById('vectorizedImplementation').checked;
        const runCoarsened = document.getElementById('coarsenedImplementation').checked;
	const runOneDTiling = document.getElementById('oneDTilingImplementation').checked;

        if (selectedWorkgroups.length === 0) {
            alert('Please select at least one workgroup size');
            return;
        }
    
        if ((runSharedMemory || runVectorized || runCoarsened || runOneDTiling) && selectedTileSizes.length === 0) {
            alert('Please select at least one tile size for Shared Memory, Vectorized, Coarsened, or 1D Tiling implementation');
            return;
        }
    
        if (!runNaive && !runSharedMemory && !runVectorized && !runCoarsened && !runOneDTiling) {
            alert('Please select at least one kernel');
            return;
        }

        results = { 
            naive: [], 
            sharedMemory: [], 
            vectorized: [], 
            coarsened: [],
            oneDTiling: []
        };

        const resultsTable = document.getElementById('resultsTable');
        resultsTable.innerHTML = `
            <table>
                <thead>
                    <tr>
                        <th>Implementation</th>
                        <th>Matrix Size</th>
                        <th>Workgroup Size</th>
                        <th>Tile Size</th>
                        <th>Vectorized</th>
                        <th>Tile Multiplier</th>
                        <th>Average Time (ms)</th>
                        <th>GFLOPS</th>
                        <th>Verified</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        `;
        const tbody = resultsTable.querySelector('tbody');
	    
        // Helper function for running implementation
        async function runImplementation(type, size, workgroupSize, tileSize = null, coarsenX = null, coarsenY = null, tilingMultiplier = null) {
            // Warm-up run
            await runBenchmark(size, workgroupSize, type, tileSize, coarsenX, coarsenY, tilingMultiplier);
        
            let totalTime = 0;
            let allVerified = true;
        
            for (let i = 0; i < iterations; i++) {
                const result = await runBenchmark(
                    size, 
                    workgroupSize, 
                    type, 
                    tileSize,
                    coarsenX,
                    coarsenY,
                    tilingMultiplier
                );
                totalTime += result.time;
                allVerified = allVerified && result.verified;
            }
        
            const avgTime = totalTime / iterations;
            const gflops = (2 * size * size * size) / (avgTime * 1e6);
        
            return {
                avgTime,
                gflops,
                verified: allVerified
            };
        }

	// Run naive implementation
        if (runNaive) {
            for (const size of selectedSizes) {
                for (const workgroupSize of selectedWorkgroups) {
                    try {
                        const result = await runImplementation('naive', size, workgroupSize);
                        
                        results.naive.push({
                            implementation: 'Naive',
                            size,
                            workgroupSize,
                            tileSize: 'N/A',
                            time: parseFloat(result.avgTime.toFixed(2)),
                            gflops: parseFloat(result.gflops.toFixed(2)),
                            verified: result.verified
                        });

                         tbody.insertRow().innerHTML = `
                             <td>Naive</td>
                             <td>${size}x${size}</td>
                             <td>${workgroupSize.replace(',', 'x')}</td>
                             <td>N/A</td>
                             <td>No</td>
                             <td>N/A</td>
                             <td>${result.avgTime.toFixed(2)}</td>
                             <td>${result.gflops.toFixed(2)}</td>
                             <td>${result.verified ? '✓' : '✗'}</td>
                        `;
                    } catch (error) {
                        console.error('Error in naive implementation:', error);
                    }
                }
            }
        }

        // Run shared memory implementation
        if (runSharedMemory) {
            for (const size of selectedSizes) {
                for (const workgroupSize of selectedWorkgroups) {
                    for (const tileSize of selectedTileSizes) {
                        try {
                            if (!isTileSizeCompatibleWithWorkgroup(tileSize, workgroupSize)) continue;

                            const result = await runImplementation('shared', size, workgroupSize, tileSize);
                            
                            results.sharedMemory.push({
                                implementation: 'Shared Memory',
                                size,
                                workgroupSize,
                                tileSize,
                                time: parseFloat(result.avgTime.toFixed(2)),
                                gflops: parseFloat(result.gflops.toFixed(2)),
                                verified: result.verified
                            });

                            tbody.insertRow().innerHTML = `
                                <td>Shared Memory</td>
                                <td>${size}x${size}</td>
                                <td>${workgroupSize.replace(',', 'x')}</td>
                                <td>${tileSize.replace(',', 'x')}</td>
                                <td>No</td>
                                <td>N/A</td>
                                <td>${result.avgTime.toFixed(2)}</td>
                                <td>${result.gflops.toFixed(2)}</td>
                                <td>${result.verified ? '✓' : '✗'}</td>
                            `;
                        } catch (error) {
                            console.error('Error in shared memory implementation:', error);
                        }
                    }
                }
            }
        }

        // Run vectorized implementation
        if (runVectorized) {
            for (const size of selectedSizes) {
                for (const workgroupSize of selectedWorkgroups) {
                    for (const tileSize of selectedTileSizes) {
                        try {
                            // Skip if tile size is too small for vectorization
                            const [tRows, tCols] = tileSize.split(',').map(Number);
                            if (tRows < 4 || tCols < 4) continue;
                            
                            if (!isTileSizeCompatibleWithWorkgroup(tileSize, workgroupSize)) continue;

                            const result = await runImplementation('vectorized', size, workgroupSize, tileSize);
                            
                            results.vectorized.push({
                                implementation: 'Vectorized',
                                size,
                                workgroupSize,
                                tileSize,
                                time: parseFloat(result.avgTime.toFixed(2)),
                                gflops: parseFloat(result.gflops.toFixed(2)),
                                verified: result.verified
                            });

                            tbody.insertRow().innerHTML = `
                                <td>Vectorized</td>
                                <td>${size}x${size}</td>
                                <td>${workgroupSize.replace(',', 'x')}</td>
                                <td>${tileSize.replace(',', 'x')}</td>
                                <td>Yes</td>
                                <td>N/A</td>
                                <td>${result.avgTime.toFixed(2)}</td>
                                <td>${result.gflops.toFixed(2)}</td>
                                <td>${result.verified ? '✓' : '✗'}</td>
                            `;
                        } catch (error) {
                            console.error('Error in vectorized implementation:', error);
                        }
                    }
                }
            }
        }

        if (runCoarsened) {
            for (const size of selectedSizes) {
                for (const workgroupSize of selectedWorkgroups) {
                    for (const tileSize of selectedTileSizes) {
                        for (const coarseningSize of selectedCoarseningSizes) {
                            try {
                                if (!isTileSizeCompatibleWithWorkgroup(tileSize, workgroupSize)) continue;
        
                                const [coarsenX, coarsenY] = coarseningSize.split(',').map(Number);
				console.log('Debug - Coarsening values:', coarsenX, coarsenY);
                                const result = await runImplementation('coarsened', size, workgroupSize, tileSize, coarsenX, coarsenY);
                                
                                results.coarsened.push({
                                    implementation: 'Coarsened',
                                    size,
                                    workgroupSize,
                                    tileSize,
                                    coarsenX,
                                    coarsenY,
                                    time: parseFloat(result.avgTime.toFixed(2)),
                                    gflops: parseFloat(result.gflops.toFixed(2)),
                                    verified: result.verified
                                });
        
                                tbody.insertRow().innerHTML = `
                                    <td>Coarsened (${coarsenX}x${coarsenY})</td>
                                    <td>${size}x${size}</td>
                                    <td>${workgroupSize.replace(',', 'x')}</td>
                                    <td>${tileSize.replace(',', 'x')}</td>
                                    <td>No</td>
                                    <td>N/A</td>
                                    <td>${result.avgTime.toFixed(2)}</td>
                                    <td>${result.gflops.toFixed(2)}</td>
                                    <td>${result.verified ? '✓' : '✗'}</td>
                                `;
                            } catch (error) {
                                console.error('Error in coarsened implementation:', error);
                            }
                        }
                    }
                }
            }
        }

        if (runOneDTiling) {
            for (const size of selectedSizes) {
                for (const workgroupSize of selectedWorkgroups) {
                    for (const tm of selectedTileMultipliers) {
                        try {
                            const result = await runImplementation('1dtiling', size, workgroupSize, null, null, null, tm);
                            
                            results.oneDTiling.push({
                                implementation: '1D Tiling',
                                size,
                                workgroupSize,
                                tileSize: `${tm}x`,
                                tilingMultiplier: tm,
                                time: parseFloat(result.avgTime.toFixed(2)),
                                gflops: parseFloat(result.gflops.toFixed(2)),
                                verified: result.verified
                            });
       
                            tbody.insertRow().innerHTML = `
                                <td>1D Tiling</td>
                                <td>${size}x${size}</td>
                                <td>${workgroupSize.replace(',', 'x')}</td>
                                <td>N/A</td>
                                <td>No</td>
                                <td>${tm}x</td>
                                <td>${result.avgTime.toFixed(2)}</td>
                                <td>${result.gflops.toFixed(2)}</td>
                                <td>${result.verified ? '✓' : '✗'}</td>
                            `;
                        } catch (error) {
                            console.error('Error in 1D Tiling implementation:', error);
                        }
                    }
                }
            }
        }

        updateChart();
        createBarCharts();
	updatePerformanceSummary();
    }

    // Download results
    function downloadResults() {
        const csv = [
            'Implementation,Matrix Size,Workgroup Size,Tile Size,Vectorized,Time (ms),GFLOPS,Verified'
        ];

        [...results.naive, 
         ...results.sharedMemory, 
         ...results.vectorized, 
         ...results.coarsened,
         ...results.oneDTiling
        ].forEach(result => {
            const coarsening = result.implementation === 'Coarsened' ? 
                `${result.coarsenX}x${result.coarsenY}` : 'N/A';
            csv.push(`${result.implementation},${result.size},${result.workgroupSize},${result.tileSize},${coarsening},${result.time.toFixed(2)},${result.gflops.toFixed(2)},${result.verified}`);
        });

        const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.setAttribute('href', url);
        a.setAttribute('download', 'benchmark_results.csv');
        a.click();
    }

    // Update device info
    async function updateDeviceInfo() {
        const deviceInfoElement = document.getElementById("deviceInfo");
        try {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }
            const adapterInfo = await adapter.requestAdapterInfo();

            deviceInfoElement.innerHTML = `
                <strong>GPU Vendor:</strong> ${adapterInfo.vendor}<br>
                <strong>GPU Architecture:</strong> ${adapterInfo.architecture}<br>
                <strong>Description:</strong> ${adapterInfo.description || 'Not available'}<br>
                <strong>Device:</strong> ${navigator.platform}<br>
                <strong>Browser:</strong> ${navigator.userAgent}
            `;
        } catch (error) {
            deviceInfoElement.innerHTML = `
                <strong>Error:</strong> ${error.message}<br>
                <strong>Device:</strong> ${navigator.platform}<br>
                <strong>Browser:</strong> ${navigator.userAgent}
            `;
        }
    }

    // Initialize
    async function initialize() {
        try {
            await initWebGPU();
            await updateDeviceInfo();
    
            // Initialize matrix size checkboxes
            const sizesContainer = document.getElementById('sizeCheckboxes');
            sizesContainer.innerHTML = matrixSizes.map(size => `
                <label>
                    <input type="checkbox" value="${size}" checked>
                    ${size}x${size}
                </label>
            `).join(' ');
    
            // Initialize workgroup size checkboxes
            const workgroupsContainer = document.getElementById('workgroupSizes');
            workgroupsContainer.innerHTML = workgroupSizes.map(size => `
                <label>
                    <input type="checkbox" value="${size}" ${size === '16,16' ? 'checked' : ''}>
                    ${size.replace(',', 'x')}
                </label>
            `).join('');
    
            // Add event listener for workgroup size changes
            document.querySelectorAll('#workgroupSizes input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', updateTileSizes);
            });
    
            // Initial update of tile sizes
            updateTileSizes();
    
            // Add coarsening configuration
            const coarseningConfig = document.createElement('div');
            coarseningConfig.className = 'config-section';
            coarseningConfig.innerHTML = `
                <div class="section-header">
                    <h4>Coarsening Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleCoarseningSizes('reset')">Reset</button>
                        <button class="small-button" onclick="handleCoarseningSizes('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="coarseningSizes" class="options-grid">
                    ${coarseningSizes.map(size => `
                        <label>
                            <input type="checkbox" value="${size}" ${size === '2,2' ? 'checked' : ''}>
                            ${size.replace(',', 'x')}
                        </label>
                    `).join('')}
                </div>
            `;
            document.querySelector('.implementation-selector').parentNode.before(coarseningConfig);
    
            const tileMultiplierConfig = document.createElement('div');
            tileMultiplierConfig.className = 'config-section';
            tileMultiplierConfig.innerHTML = `
                <div class="section-header">
                    <h4>Tile Multiplier Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleTileMultiplierSizes('reset')">Reset</button>
                        <button class="small-button" onclick="handleTileMultiplierSizes('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="tileMultiplierSizes" class="options-grid">
                    ${tileMultiplierSizes.map(tm => `
                        <label>
                            <input type="checkbox" value="${tm}" ${tm === 4 ? 'checked' : ''}>
                            ${tm}x
                        </label>
                    `).join('')}
                </div>
            `;
            
            document.querySelector('.implementation-selector').parentNode.before(tileMultiplierConfig);

            // Event listeners for buttons
            document.getElementById('generateMatrices').addEventListener('click', async () => {
                const selectedSizes = Array.from(document.querySelectorAll('#sizeCheckboxes input:checked'))
                    .map(cb => parseInt(cb.value));
                if (selectedSizes.length === 0) {
                    alert('Please select at least one matrix size');
                    return;
                }
                try {
                    document.getElementById('generateMatrices').disabled = true;
                    document.getElementById('generateMatrices').textContent = 'Generating...';
                    await generateMatrices(selectedSizes);
                    alert('Matrices generated successfully!');
                } catch (error) {
                    console.error('Error generating matrices:', error);
                    alert('Error generating matrices: ' + error.message);
                } finally {
                    document.getElementById('generateMatrices').disabled = false;
                    document.getElementById('generateMatrices').textContent = 'Generate Matrices';
                }
            });
    
            document.getElementById('runBenchmark').addEventListener('click', async () => {
                try {
                    document.getElementById('runBenchmark').disabled = true;
                    document.getElementById('runBenchmark').textContent = 'Running...';
                    await performBenchmark();
                } catch (error) {
                    console.error('Error running benchmark:', error);
                    alert('Error running benchmark: ' + error.message);
                } finally {
                    document.getElementById('runBenchmark').disabled = false;
                    document.getElementById('runBenchmark').textContent = 'Run Benchmark';
                }
            });
    
            document.getElementById('downloadResults').addEventListener('click', downloadResults);
    
        } catch (error) {
            console.error('Initialization failed:', error);
            alert('Failed to initialize WebGPU: ' + error.message);
        }
    }

    // Handle matrix size selection buttons
    function handleMatrixSizes(action) {
        const checkboxes = document.querySelectorAll('#sizeCheckboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = action === 'selectAll';
        });
    }

    // Handle workgroup selection buttons
    function handleWorkgroups(action) {
        const checkboxes = document.querySelectorAll('#workgroupSizes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = action === 'selectAll';
        });
        updateTileSizes();
    }

    // Handle tile size selection buttons
    function handleTileSizes(action) {
        const checkboxes = document.querySelectorAll('#tileSizes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = action === 'selectAll';
        });
    }

    //Handle coarsening sizes
    function handleCoarseningSizes(action) {
        const checkboxes = document.querySelectorAll('#coarseningSizes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = action === 'selectAll';
            if (action === 'reset' && checkbox.value === '2,2') {
                checkbox.checked = true;
            }
        });
    }

    function handleTileMultiplierSizes(action) {
        const checkboxes = document.querySelectorAll('#tileMultiplierSizes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            if (action === 'selectAll') {
                checkbox.checked = true;
            } else if (action === 'reset') {
                checkbox.checked = parseInt(checkbox.value) === 4;
            }
        });
    }
    window.addEventListener('load', initialize);
    </script>
</body>
</html>
