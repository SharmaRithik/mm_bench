
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Multiplication Benchmark</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .tile {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-container {
            height: 500px;
	    position: relative;
	    width: 100%;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
        }
        .matrix-sizes {
            margin: 10px 0;
        }
        .config-section {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .config-section h4 {
            margin-top: 0;
        }
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .options-grid label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            white-space: nowrap;
        }
        #sizeCheckboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        #sizeCheckboxes label {
            white-space: nowrap;
        }
        .button-group {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            margin-left: 16px;
        }
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .small-button {
            padding: 4px 8px;
            font-size: 12px;
            background-color: #6c757d;
        }
        .bar-charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            padding: 10px;
        }
        .bar-chart-wrapper {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            height: 400px;
        }
        .implementation-selector {
            margin: 10px 0;
        }
        .implementation-selector label {
            margin-right: 15px;
        }
        .tile-options {
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        .tile-options.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .tile-size-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }
        .performance-summary {
            overflow-x: auto;
        }
        
        #performanceSummaryTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        #performanceSummaryTable th,
        #performanceSummaryTable td {
            padding: 8px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        #performanceSummaryTable th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        #performanceSummaryTable tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        #performanceSummaryTable tr:hover {
            background-color: #f5f5f5;
        }
        
        .method-cell {
            font-weight: 500;
        }
        
        .time-cell {
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="tile">
            <h2>Matrix Multiplication Benchmark</h2>
            <div id="deviceInfo"></div>
        </div>
        
        <div class="tile">
            <h3>Configuration</h3>
            <div class="config-section">
                <div class="section-header">
                    <h4>Matrix Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleMatrixSizes('reset')">Reset</button>
                        <button class="small-button" onclick="handleMatrixSizes('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="sizeCheckboxes"></div>
            </div>
            
            <div class="config-section">
                <div class="section-header">
                    <h4>Workgroup Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleWorkgroups('reset')">Reset</button>
                        <button class="small-button" onclick="handleWorkgroups('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="workgroupSizes" class="options-grid"></div>
            </div>

            <div class="config-section">
                <div class="section-header">
                    <h4>Tile Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleTileSizes('reset')">Reset</button>
                        <button class="small-button" onclick="handleTileSizes('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="tileSizes" class="options-grid"></div>
            </div>

            <div class="config-section">
                <div class="implementation-selector">
                    <h4>Kernels:</h4>
                    <label>
                        <input type="checkbox" id="naiveImplementation" checked>
                        Naive
                    </label>
                    <label>
                        <input type="checkbox" id="sharedMemoryImplementation" checked>
                        Shared Memory Tiling
                    </label>
                    <label>
                        <input type="checkbox" id="vectorizedImplementation" checked>
                        Vectorized
                    </label>
                </div>
            </div>

            <div class="config-section">
                <label for="iterations">Number of iterations:</label>
                <input type="number" id="iterations" value="1" min="1" max="100">
            </div>

            <div>
                <button id="generateMatrices">Generate Matrices</button>
                <button id="runBenchmark">Run Benchmark</button>
                <button id="downloadResults">Download Results</button>
            </div>
        </div>

        <div class="tile">
            <h3>Results</h3>
            <div id="resultsTable"></div>
        </div>

        <div class="tile">
            <h3>Performance Comparison</h3>
            <div class="chart-container">
                <canvas id="benchmarkChart"></canvas>
            </div>
        </div>

        <div class="tile">
            <h3>Performance by Matrix Size</h3>
            <div id="barChartsContainer" class="bar-charts-container">
            </div>
        </div>
        <div class="tile">
            <h3>Performance Summary</h3>
            <div class="performance-summary">
                <table id="performanceSummaryTable">
                    <thead>
                        <tr>
                            <th>Matrix Size</th>
                            <th colspan="2">Best Performance</th>
                            <th colspan="2">Second Best</th>
                            <th colspan="2">Third Best</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
// Configuration
    const matrixSizes = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];

    // Generate workgroup sizes based on the specified logic
    const workgroupSizes = [];
    for (let x = 0; x <= 8; x++) {
        for (let y = 0; y <= 8; y++) {
            const xDim = Math.pow(2, x);
            const yDim = Math.pow(2, y);
            if (xDim * yDim <= 256) {
                workgroupSizes.push(`${xDim},${yDim}`);
            }
        }
    }

    let device;
    let generatedMatrices = {};
    let benchmarkChart;
    let results = {
        naive: [],
        sharedMemory: [],
        vectorized: []
    };

    // Generate tile sizes for a given workgroup size
    function generateTileSizes(workgroupSize) {
        const [wx, wy] = workgroupSize.split(',').map(Number);
        const tileSizes = new Set();
        
        // Get maximum allowed power of 2 for each dimension
        const maxPowerX = Math.floor(Math.log2(wx));
        const maxPowerY = Math.floor(Math.log2(wy));
        
        // Generate all possible rectangular combinations
        for (let px = 0; px <= maxPowerX; px++) {
            for (let py = 0; py <= maxPowerY; py++) {
                const tileX = Math.pow(2, px);
                const tileY = Math.pow(2, py);
                
                // Add the rectangular tile size
                tileSizes.add(`${tileX},${tileY}`);
            }
        }
        
        return Array.from(tileSizes);
    }

    // Update validation function for tile size compatibility
    function isTileSizeCompatibleWithWorkgroup(tileSize, workgroupSize) {
        const [tileWidth, tileHeight] = tileSize.split(',').map(Number);
        const [workgroupWidth, workgroupHeight] = workgroupSize.split(',').map(Number);
        
        // Each tile dimension must fit within its corresponding workgroup dimension
        return tileWidth <= workgroupWidth && tileHeight <= workgroupHeight;
    }

    // Update tile size options based on selected workgroup
    function updateTileSizes() {
        const selectedWorkgroups = Array.from(document.querySelectorAll('#workgroupSizes input:checked'))
            .map(cb => cb.value);

        const tileSizesContainer = document.getElementById('tileSizes');
        const allTileSizes = new Set();

        selectedWorkgroups.forEach(workgroupSize => {
            generateTileSizes(workgroupSize).forEach(size => allTileSizes.add(size));
        });

        tileSizesContainer.innerHTML = Array.from(allTileSizes).sort((a, b) => {
            const [aSize] = a.split(',').map(Number);
            const [bSize] = b.split(',').map(Number);
            return aSize - bSize;
        }).map(size => `
            <label>
                <input type="checkbox" value="${size}" ${size === '16,16' ? 'checked' : ''}>
                ${size.replace(',', 'x')}
            </label>
        `).join('');
    }

    // Naive WGSL implementation
    function getNaiveWGSL(workgroupSize) {
        const [wx, wy] = workgroupSize.split(',').map(Number);
        return `
            @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
            @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
            @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
            @group(0) @binding(3) var<uniform> uniforms : Uniforms;

            struct Uniforms {
                N : u32,
                alpha : f32,
                beta : f32,
            }

            @compute @workgroup_size(${wx}, ${wy})
            fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                let N = uniforms.N;
                let row = global_id.y;
                let col = global_id.x;

                if (row >= N || col >= N) {
                    return;
                }

                let row_offset = row * N;
                var sum: f32 = 0.0;

                for (var k = 0u; k < N; k = k + 1u) {
                    let a = matrixA[row_offset + k];
                    let b = matrixB[k * N + col];
                    sum = sum + a * b;
                }

                matrixC[row_offset + col] = uniforms.alpha * sum + uniforms.beta * matrixC[row_offset + col];
            }
        `;
    }

    // Shared Memory Tiling WGSL implementation
    function getNaiveDecoupledSharedMemoryWGSL(workgroupSize, tileSize) {
        const [THREADS_X, THREADS_Y] = workgroupSize.split(',').map(Number);
        const [TUNE_SPLIT, _] = tileSize.split(',').map(Number);
        
        return `
            @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
            @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
            @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
            @group(0) @binding(3) var<uniform> uniforms : Uniforms;
    
            struct Uniforms {
                N : u32,
                alpha : f32,
                beta : f32,
            }
    
            const THREADS_X = ${THREADS_X}u;
            const THREADS_Y = ${THREADS_Y}u;
            const TUNE_SPLIT = ${TUNE_SPLIT}u;
    
            fn index2D(row: u32, col: u32, stride: u32) -> u32 {
                return row * stride + col;
            }
    
            var<workgroup> A_shared: array<f32, ${THREADS_Y * TUNE_SPLIT}>;
            var<workgroup> B_shared: array<f32, ${TUNE_SPLIT * THREADS_X}>;
    
            @compute @workgroup_size(${THREADS_X}, ${THREADS_Y})
            fn main(
                @builtin(global_invocation_id) global_id: vec3<u32>,
                @builtin(local_invocation_id) local_id: vec3<u32>,
                @builtin(workgroup_id) workgroup_id: vec3<u32>
            ) {
                let N = uniforms.N;
                let i = global_id.y;
                let j = global_id.x;
                let local_i = local_id.y;
                let local_j = local_id.x;
                
                var value: f32 = 0.0;
                
                for (var outer_k: u32 = 0u; outer_k < N; outer_k += TUNE_SPLIT) {
                    // Cache data from global memory to shared memory for A
                    for (var local_j_stride = local_j; 
                         local_j_stride < TUNE_SPLIT; 
                         local_j_stride += THREADS_X) {
                        let shared_idx = index2D(local_i, local_j_stride, TUNE_SPLIT);
                        let global_idx = index2D(i, outer_k + local_j_stride, N);
                        
                        var data_a = 0.0;
                        if (i < N && (outer_k + local_j_stride) < N) {
                            data_a = matrixA[global_idx];
                        }
                        A_shared[shared_idx] = data_a;
                    }
                    
                    // Cache data from global memory to shared memory for B
                    for (var local_i_stride = local_i; 
                         local_i_stride < TUNE_SPLIT; 
                         local_i_stride += THREADS_Y) {
                        let shared_idx = index2D(local_i_stride, local_j, THREADS_X);
                        let global_idx = index2D(outer_k + local_i_stride, j, N);
                        
                        var data_b = 0.0;
                        if ((outer_k + local_i_stride) < N && j < N) {
                            data_b = matrixB[global_idx];
                        }
                        B_shared[shared_idx] = data_b;
                    }
                    
                    // Synchronize all threads in the workgroup
                    workgroupBarrier();
                    
                    // Compute partial results using shared memory
                    if (i < N && j < N) {
                        for (var inner_k: u32 = 0u; inner_k < TUNE_SPLIT; inner_k = inner_k + 1u) {
                            if (outer_k + inner_k < N) {
                                let a_idx = index2D(local_i, inner_k, TUNE_SPLIT);
                                let b_idx = index2D(inner_k, local_j, THREADS_X);
                                value = value + A_shared[a_idx] * B_shared[b_idx];
                            }
                        }
                    }
                    
                    // Synchronize before next iteration
                    workgroupBarrier();
                }
                
                // Write final result
                if (i < N && j < N) {
                    let result_idx = index2D(i, j, N);
                    matrixC[result_idx] = uniforms.alpha * value + uniforms.beta * matrixC[result_idx];
                }
            }
        `;
    }

    // Vectorized Shared Memory WGSL implementation
    function getVectorizedSharedMemoryWGSL(workgroupSize, tileSize) {
        const [workgroupRows, workgroupCols] = workgroupSize.split(',').map(Number);
        const [tileRows, tileCols] = tileSize.split(',').map(Number);
        
        if (tileRows < 4 || tileCols < 4) {
            throw new Error('Vectorized implementation requires tile size >= 4');
        }

        return `
            @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
            @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
            @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
            @group(0) @binding(3) var<uniform> uniforms : Uniforms;

            struct Uniforms {
                N : u32,
                alpha : f32,
                beta : f32,
            }

            const TILE_SIZE = ${tileRows}u;
            const WG_SIZE = ${workgroupRows}u;
            const VEC_SIZE = 4u;

            var<workgroup> tileA: array<f32, ${workgroupRows * workgroupCols}>;
            var<workgroup> tileB: array<f32, ${workgroupRows * workgroupCols}>;

            @compute @workgroup_size(${workgroupRows}, ${workgroupCols})
            fn main(
                @builtin(global_invocation_id) global_id: vec3<u32>,
                @builtin(local_invocation_id) local_id: vec3<u32>,
                @builtin(workgroup_id) workgroup_id: vec3<u32>
            ) {
                let N = uniforms.N;
                let row = global_id.y;
                let col = global_id.x;
                let localRow = local_id.y;
                let localCol = local_id.x;
                let localIdx = localRow * WG_SIZE + localCol;
                
                var acc = 0.0;
                let numTiles = (N + TILE_SIZE - 1u) / TILE_SIZE;

                for (var tile = 0u; tile < numTiles; tile = tile + 1u) {
                    let tileOffset = tile * TILE_SIZE;

                    if (row < N && (tileOffset + localCol) < N) {
                        if (localCol % VEC_SIZE == 0u && (tileOffset + localCol + VEC_SIZE) <= N) {
                            let baseIdx = row * N + tileOffset + localCol;
                            tileA[localIdx] = matrixA[baseIdx];
                            tileA[localIdx + 1u] = matrixA[baseIdx + 1u];
                            tileA[localIdx + 2u] = matrixA[baseIdx + 2u];
                            tileA[localIdx + 3u] = matrixA[baseIdx + 3u];
                        } else {
                            tileA[localIdx] = matrixA[row * N + tileOffset + localCol];
                        }
                    } else {
                        tileA[localIdx] = 0.0;
                    }

                    if ((tileOffset + localRow) < N && col < N) {
                        if (localRow % VEC_SIZE == 0u && (tileOffset + localRow + VEC_SIZE) <= N) {
                            let baseIdx = (tileOffset + localRow) * N + col;
                            tileB[localIdx] = matrixB[baseIdx];
                            tileB[localIdx + WG_SIZE] = matrixB[baseIdx + N];
                            tileB[localIdx + 2u * WG_SIZE] = matrixB[baseIdx + 2u * N];
                            tileB[localIdx + 3u * WG_SIZE] = matrixB[baseIdx + 3u * N];
                        } else {
                            tileB[localIdx] = matrixB[(tileOffset + localRow) * N + col];
                        }
                    } else {
                        tileB[localIdx] = 0.0;
                    }

                    workgroupBarrier();

                    if (row < N && col < N) {
                        for (var k = 0u; k < TILE_SIZE; k = k + VEC_SIZE) {
                            if (k + VEC_SIZE <= TILE_SIZE) {
                                let aVec = vec4<f32>(
                                    tileA[localRow * WG_SIZE + k],
                                    tileA[localRow * WG_SIZE + k + 1u],
                                    tileA[localRow * WG_SIZE + k + 2u],
                                    tileA[localRow * WG_SIZE + k + 3u]
                                );
                                let bVec = vec4<f32>(
                                    tileB[k * WG_SIZE + localCol],
                                    tileB[(k + 1u) * WG_SIZE + localCol],
                                    tileB[(k + 2u) * WG_SIZE + localCol],
                                    tileB[(k + 3u) * WG_SIZE + localCol]
                                );
                                acc += dot(aVec, bVec);
                            }
                        }
                    }

                    workgroupBarrier();
                }

                if (row < N && col < N) {
                    let index = row * N + col;
                    matrixC[index] = uniforms.alpha * acc + uniforms.beta * matrixC[index];
                }
            }
        `;
    }

    // Initialize WebGPU
    async function initWebGPU() {
        if (!navigator.gpu) {
            throw new Error("WebGPU not supported");
        }
        const adapter = await navigator.gpu.requestAdapter();
        device = await adapter.requestDevice();
        return device;
    }
			    
    // Create buffer helper function
    function createBuffer(data, usage) {
        const buffer = device.createBuffer({
            size: data.byteLength,
            usage: usage,
            mappedAtCreation: true,
        });
        new Float32Array(buffer.getMappedRange()).set(data);
        buffer.unmap();
        return buffer;
    }

    function updatePerformanceSummary() {
        const matrixSizes = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
        const tbody = document.querySelector('#performanceSummaryTable tbody');
        tbody.innerHTML = '';
    
        matrixSizes.forEach(size => {
            // Combine all results for this size
            const sizeResults = [
                ...results.naive.filter(r => r.size === size),
                ...results.sharedMemory.filter(r => r.size === size),
                ...results.vectorized.filter(r => r.size === size)
            ].sort((a, b) => a.time - b.time);
    
            if (sizeResults.length === 0) return;
    
            const row = document.createElement('tr');
    
            // Add matrix size cell
            const sizeCell = document.createElement('td');
            sizeCell.textContent = `${size}x${size}`;
            row.appendChild(sizeCell);
    
            // Add top 3 performers
            for (let i = 0; i < 3; i++) {
                const result = sizeResults[i];
                if (result) {
                    // Method cell
                    const methodCell = document.createElement('td');
                    methodCell.className = 'method-cell';
                    const implementation = result.implementation === 'Shared Memory' ?
                        'sharedMemory' : result.implementation.toLowerCase();
                    methodCell.textContent = `${implementation} (${result.workgroupSize.replace(',', 'x')})`;
                    row.appendChild(methodCell);
    
                    // Time cell
                    const timeCell = document.createElement('td');
                    timeCell.className = 'time-cell';
                    timeCell.textContent = `${result.time.toFixed(2)} ms`;
                    row.appendChild(timeCell);
                } else {
                    // Empty cells if no result
                    const methodCell = document.createElement('td');
                    methodCell.className = 'method-cell';
                    methodCell.textContent = 'N/A';
                    row.appendChild(methodCell);
    
                    const timeCell = document.createElement('td');
                    timeCell.className = 'time-cell';
                    timeCell.textContent = 'N/A';
                    row.appendChild(timeCell);
                }
            }
    
            tbody.appendChild(row);
        });
    }

    // Generate matrices
    async function generateMatrices(sizes) {
        for (const N of sizes) {
            const matrixSize = N * N;
            const matrixA = new Float32Array(matrixSize);
            const matrixB = new Float32Array(matrixSize);

            for (let i = 0; i < matrixSize; i++) {
                matrixA[i] = Math.random();
                matrixB[i] = Math.random();
            }

            const bufferA = createBuffer(matrixA, GPUBufferUsage.STORAGE);
            const bufferB = createBuffer(matrixB, GPUBufferUsage.STORAGE);

            generatedMatrices[N] = { bufferA, bufferB, matrixA, matrixB };
        }
    }

    // Verify matrix multiplication
    function verifyMatrixMultiplication(matrixA, matrixB, resultMatrix, N, alpha, beta) {
        for (let check = 0; check < 5; check++) {
            const row = Math.floor(Math.random() * N);
            const col = Math.floor(Math.random() * N);
            let expected = 0;
            for (let i = 0; i < N; i++) {
                expected += matrixA[row * N + i] * matrixB[i * N + col];
            }
            expected = alpha * expected + beta * 0;
            const actual = resultMatrix[row * N + col];
            const relativeError = Math.abs((expected - actual) / expected);
            if (relativeError > 1e-5) {
                return false;
            }
        }
        return true;
    }

    // Run benchmark
    async function runBenchmark(N, workgroupSize, implementation = 'naive', tileSize = null) {
        let shaderCode;
        switch(implementation) {
            case 'naive':
                shaderCode = getNaiveWGSL(workgroupSize);
                break;
            case 'shared':
                shaderCode = getNaiveDecoupledSharedMemoryWGSL(workgroupSize, tileSize);
                break;
            case 'vectorized':
                shaderCode = getVectorizedSharedMemoryWGSL(workgroupSize, tileSize);
                break;
            default:
                throw new Error('Unknown implementation');
        }

        const shaderModule = device.createShaderModule({
            code: shaderCode
        });

        const { bufferA, bufferB, matrixA, matrixB } = generatedMatrices[N];
        const matrixSize = N * N;
        const resultMatrix = new Float32Array(matrixSize).fill(0);
        const bufferC = createBuffer(resultMatrix, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);

        const uniformBuffer = device.createBuffer({
            size: 16,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const uniformData = new ArrayBuffer(16);
        new Uint32Array(uniformData, 0, 1)[0] = N;
        new Float32Array(uniformData, 4, 1)[0] = 1.0;
        new Float32Array(uniformData, 8, 1)[0] = 0.0;
        device.queue.writeBuffer(uniformBuffer, 0, uniformData);

        const bindGroupLayout = device.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
            ],
        });

        const bindGroup = device.createBindGroup({
            layout: bindGroupLayout,
            entries: [
                { binding: 0, resource: { buffer: bufferA } },
                { binding: 1, resource: { buffer: bufferB } },
                { binding: 2, resource: { buffer: bufferC } },
                { binding: 3, resource: { buffer: uniformBuffer } },
            ],
        });

        const pipeline = device.createComputePipeline({
            layout: device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout],
            }),
            compute: {
                module: shaderModule,
                entryPoint: "main",
            },
        });

        const [wx, wy] = workgroupSize.split(',').map(Number);
        const commandEncoder = device.createCommandEncoder();
        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.dispatchWorkgroups(Math.ceil(N / wx), Math.ceil(N / wy));
        passEncoder.end();

        const startTime = performance.now();
        device.queue.submit([commandEncoder.finish()]);
        await device.queue.onSubmittedWorkDone();
        const endTime = performance.now();

        const resultReadBuffer = device.createBuffer({
            size: bufferC.size,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        });

        const readbackEncoder = device.createCommandEncoder();
        readbackEncoder.copyBufferToBuffer(bufferC, 0, resultReadBuffer, 0, bufferC.size);
        device.queue.submit([readbackEncoder.finish()]);

        await resultReadBuffer.mapAsync(GPUMapMode.READ);
        const resultArray = new Float32Array(resultReadBuffer.getMappedRange());
        const isVerified = verifyMatrixMultiplication(matrixA, matrixB, resultArray, N, 1.0, 0.0);
        resultReadBuffer.unmap();

        return {
            time: endTime - startTime,
            verified: isVerified
        };
    }

    // Perform benchmark with validation
    async function performBenchmark() {
        const iterations = parseInt(document.getElementById('iterations').value);
        const selectedSizes = Array.from(document.querySelectorAll('#sizeCheckboxes input:checked'))
            .map(cb => parseInt(cb.value));

        const selectedWorkgroups = Array.from(document.querySelectorAll('#workgroupSizes input:checked'))
            .map(cb => cb.value);

        const selectedTileSizes = Array.from(document.querySelectorAll('#tileSizes input:checked'))
            .map(cb => cb.value);

        const runNaive = document.getElementById('naiveImplementation').checked;
        const runSharedMemory = document.getElementById('sharedMemoryImplementation').checked;
        const runVectorized = document.getElementById('vectorizedImplementation').checked;

        if (selectedWorkgroups.length === 0) {
            alert('Please select at least one workgroup size');
            return;
        }

        if ((runSharedMemory || runVectorized) && selectedTileSizes.length === 0) {
            alert('Please select at least one tile size for Shared Memory or Vectorized implementation');
            return;
        }

        if (!runNaive && !runSharedMemory && !runVectorized) {
            alert('Please select at least one kernel');
            return;
        }

        results = { naive: [], sharedMemory: [], vectorized: [] };

        const resultsTable = document.getElementById('resultsTable');
        resultsTable.innerHTML = `
            <table>
                <thead>
                    <tr>
                        <th>Implementation</th>
                        <th>Matrix Size</th>
                        <th>Workgroup Size</th>
                        <th>Tile Size</th>
                        <th>Vectorized</th>
                        <th>Average Time (ms)</th>
                        <th>GFLOPS</th>
                        <th>Verified</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        `;
        const tbody = resultsTable.querySelector('tbody');

        // Helper function for running implementation
        async function runImplementation(type, size, workgroupSize, tileSize = null) {
            // Warm-up run
            await runBenchmark(size, workgroupSize, type, tileSize);

            let totalTime = 0;
            let allVerified = true;

            for (let i = 0; i < iterations; i++) {
                const result = await runBenchmark(size, workgroupSize, type, tileSize);
                totalTime += result.time;
                allVerified = allVerified && result.verified;
            }

            const avgTime = totalTime / iterations;
            const gflops = (2 * size * size * size) / (avgTime * 1e6);

            return {
                avgTime,
                gflops,
                verified: allVerified
            };
        }
	// Run naive implementation
        if (runNaive) {
            for (const size of selectedSizes) {
                for (const workgroupSize of selectedWorkgroups) {
                    try {
                        const result = await runImplementation('naive', size, workgroupSize);
                        
                        results.naive.push({
                            implementation: 'Naive',
                            size,
                            workgroupSize,
                            tileSize: 'N/A',
                            time: parseFloat(result.avgTime.toFixed(2)),
                            gflops: parseFloat(result.gflops.toFixed(2)),
                            verified: result.verified
                        });

                        tbody.insertRow().innerHTML = `
                            <td>Naive</td>
                            <td>${size}x${size}</td>
                            <td>${workgroupSize.replace(',', 'x')}</td>
                            <td>N/A</td>
                            <td>N/A</td>
                            <td>${result.avgTime.toFixed(2)}</td>
                            <td>${result.gflops.toFixed(2)}</td>
                            <td>${result.verified ? '✓' : '✗'}</td>
                        `;
                    } catch (error) {
                        console.error('Error in naive implementation:', error);
                    }
                }
            }
        }

        // Run shared memory implementation
        if (runSharedMemory) {
            for (const size of selectedSizes) {
                for (const workgroupSize of selectedWorkgroups) {
                    for (const tileSize of selectedTileSizes) {
                        try {
                            if (!isTileSizeCompatibleWithWorkgroup(tileSize, workgroupSize)) continue;

                            const result = await runImplementation('shared', size, workgroupSize, tileSize);
                            
                            results.sharedMemory.push({
                                implementation: 'Shared Memory',
                                size,
                                workgroupSize,
                                tileSize,
                                time: parseFloat(result.avgTime.toFixed(2)),
                                gflops: parseFloat(result.gflops.toFixed(2)),
                                verified: result.verified
                            });

                            tbody.insertRow().innerHTML = `
                                <td>Shared Memory</td>
                                <td>${size}x${size}</td>
                                <td>${workgroupSize.replace(',', 'x')}</td>
                                <td>${tileSize.replace(',', 'x')}</td>
                                <td>N/A</td>
                                <td>${result.avgTime.toFixed(2)}</td>
                                <td>${result.gflops.toFixed(2)}</td>
                                <td>${result.verified ? '✓' : '✗'}</td>
                            `;
                        } catch (error) {
                            console.error('Error in shared memory implementation:', error);
                        }
                    }
                }
            }
        }

        // Run vectorized implementation
        if (runVectorized) {
            for (const size of selectedSizes) {
                for (const workgroupSize of selectedWorkgroups) {
                    for (const tileSize of selectedTileSizes) {
                        try {
                            // Skip if tile size is too small for vectorization
                            const [tRows, tCols] = tileSize.split(',').map(Number);
                            if (tRows < 4 || tCols < 4) continue;
                            
                            if (!isTileSizeCompatibleWithWorkgroup(tileSize, workgroupSize)) continue;

                            const result = await runImplementation('vectorized', size, workgroupSize, tileSize);
                            
                            results.vectorized.push({
                                implementation: 'Vectorized',
                                size,
                                workgroupSize,
                                tileSize,
                                time: parseFloat(result.avgTime.toFixed(2)),
                                gflops: parseFloat(result.gflops.toFixed(2)),
                                verified: result.verified
                            });

                            tbody.insertRow().innerHTML = `
                                <td>Vectorized</td>
                                <td>${size}x${size}</td>
                                <td>${workgroupSize.replace(',', 'x')}</td>
                                <td>${tileSize.replace(',', 'x')}</td>
                                <td>Yes</td>
                                <td>${result.avgTime.toFixed(2)}</td>
                                <td>${result.gflops.toFixed(2)}</td>
                                <td>${result.verified ? '✓' : '✗'}</td>
                            `;
                        } catch (error) {
                            console.error('Error in vectorized implementation:', error);
                        }
                    }
                }
            }
        }

        updateChart();
        createBarCharts();
	updatePerformanceSummary();
    }

    // Download results
    function downloadResults() {
        const csv = [
            'Implementation,Matrix Size,Workgroup Size,Tile Size,Vectorized,Time (ms),GFLOPS,Verified'
        ];

        [...results.naive, ...results.sharedMemory, ...results.vectorized].forEach(result => {
            csv.push(`${result.implementation},${result.size},${result.workgroupSize},${result.tileSize},${result.implementation === 'Vectorized' ? 'Yes' : 'N/A'},${result.time.toFixed(2)},${result.gflops.toFixed(2)},${result.verified}`);
        });

        const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.setAttribute('href', url);
        a.setAttribute('download', 'benchmark_results.csv');
        a.click();
    }

    // Update device info
    async function updateDeviceInfo() {
        const deviceInfoElement = document.getElementById("deviceInfo");
        try {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }
            const adapterInfo = await adapter.requestAdapterInfo();

            deviceInfoElement.innerHTML = `
                <strong>GPU Vendor:</strong> ${adapterInfo.vendor}<br>
                <strong>GPU Architecture:</strong> ${adapterInfo.architecture}<br>
                <strong>Description:</strong> ${adapterInfo.description || 'Not available'}<br>
                <strong>Device:</strong> ${navigator.platform}<br>
                <strong>Browser:</strong> ${navigator.userAgent}
            `;
        } catch (error) {
            deviceInfoElement.innerHTML = `
                <strong>Error:</strong> ${error.message}<br>
                <strong>Device:</strong> ${navigator.platform}<br>
                <strong>Browser:</strong> ${navigator.userAgent}
            `;
        }
    }

    // Initialize
    async function initialize() {
        try {
            await initWebGPU();
            await updateDeviceInfo();

            // Initialize matrix size checkboxes
            const sizesContainer = document.getElementById('sizeCheckboxes');
            sizesContainer.innerHTML = matrixSizes.map(size => `
                <label>
                    <input type="checkbox" value="${size}" checked>
                    ${size}x${size}
                </label>
            `).join(' ');

            // Initialize workgroup size checkboxes
            const workgroupsContainer = document.getElementById('workgroupSizes');
            workgroupsContainer.innerHTML = workgroupSizes.map(size => `
                <label>
                    <input type="checkbox" value="${size}" ${size === '16,16' ? 'checked' : ''}>
                    ${size.replace(',', 'x')}
                </label>
            `).join('');

            // Add event listener for workgroup size changes
            document.querySelectorAll('#workgroupSizes input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', updateTileSizes);
            });

            // Initial update of tile sizes
            updateTileSizes();

            // Event listeners for buttons
            document.getElementById('generateMatrices').addEventListener('click', async () => {
                const selectedSizes = Array.from(document.querySelectorAll('#sizeCheckboxes input:checked'))
                    .map(cb => parseInt(cb.value));
                if (selectedSizes.length === 0) {
                    alert('Please select at least one matrix size');
                    return;
                }
                try {
                    document.getElementById('generateMatrices').disabled = true;
                    document.getElementById('generateMatrices').textContent = 'Generating...';
                    await generateMatrices(selectedSizes);
                    alert('Matrices generated successfully!');
                } catch (error) {
                    console.error('Error generating matrices:', error);
                    alert('Error generating matrices: ' + error.message);
                } finally {
                    document.getElementById('generateMatrices').disabled = false;
                    document.getElementById('generateMatrices').textContent = 'Generate Matrices';
                }
            });

            document.getElementById('runBenchmark').addEventListener('click', async () => {
                try {
                    document.getElementById('runBenchmark').disabled = true;
                    document.getElementById('runBenchmark').textContent = 'Running...';
                    await performBenchmark();
                } catch (error) {
                    console.error('Error running benchmark:', error);
                    alert('Error running benchmark: ' + error.message);
                } finally {
                    document.getElementById('runBenchmark').disabled = false;
                    document.getElementById('runBenchmark').textContent = 'Run Benchmark';
                }
            });

            document.getElementById('downloadResults').addEventListener('click', downloadResults);

        } catch (error) {
            console.error('Initialization failed:', error);
            alert('Failed to initialize WebGPU: ' + error.message);
        }
    }

    // Handle matrix size selection buttons
    function handleMatrixSizes(action) {
        const checkboxes = document.querySelectorAll('#sizeCheckboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = action === 'selectAll';
        });
    }

    // Handle workgroup selection buttons
    function handleWorkgroups(action) {
        const checkboxes = document.querySelectorAll('#workgroupSizes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = action === 'selectAll';
        });
        updateTileSizes();
    }

    // Handle tile size selection buttons
    function handleTileSizes(action) {
        const checkboxes = document.querySelectorAll('#tileSizes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = action === 'selectAll';
        });
    }

    // Update chart
    function updateChart() {
        const ctx = document.getElementById('benchmarkChart').getContext('2d');
    
        if (benchmarkChart) {
            benchmarkChart.destroy();
        }
    
        const datasets = [];
        const colors = [
            'rgb(75, 192, 192)', 'rgb(255, 99, 132)', 'rgb(54, 162, 235)',
            'rgb(255, 206, 86)', 'rgb(153, 102, 255)', 'rgb(255, 159, 64)'
        ];
    
        let colorIndex = 0;
        const matrixSizes = [...new Set([...results.naive, ...results.sharedMemory, ...results.vectorized]
            .map(r => r.size))].sort((a, b) => a - b);
    
        // Add datasets for each implementation
        ['naive', 'sharedMemory', 'vectorized'].forEach(implType => {
            if (!results[implType] || results[implType].length === 0) return;
    
            const configs = [...new Set(results[implType].map(r =>
                `${r.workgroupSize}${r.tileSize ? ',' + r.tileSize : ''}`
            ))];
    
            configs.forEach(config => {
                const [workgroupSize, tileSize] = config.split(',');
                const implResults = results[implType].filter(r =>
                    r.workgroupSize === workgroupSize && 
                    (tileSize ? r.tileSize === tileSize : true)
                );
    
                if (implResults.length > 0) {
                    // Sort results by matrix size to ensure correct line plotting
                    implResults.sort((a, b) => a.size - b.size);
    
                    const label = implType === 'naive' ? 
                        `Naive WG ${workgroupSize.replace(',', 'x')}` :
                        `${implType === 'vectorized' ? 'Vectorized' : 'Shared Memory'} WG ${workgroupSize.replace(',', 'x')}${tileSize ? ' Tile ' + tileSize.replace(',', 'x') : ''}`;
    
                    datasets.push({
                        label: label,
                        data: implResults.map(r => ({
                            x: r.size,
                            y: r.time
                        })),
                        borderColor: colors[colorIndex % colors.length],
                        backgroundColor: colors[colorIndex % colors.length].replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        borderDash: implType === 'vectorized' ? [5, 5] : [],
                        tension: 0.1,
                        fill: false
                    });
                    colorIndex++;
                }
            });
        });
    
        benchmarkChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: datasets
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: {
                            display: true,
                            text: 'Matrix Size'
                        },
                        ticks: {
                            callback: function(value) {
                                return `${value}x${value}`;
                            }
                        }
                    },
                    y: {
                        type: 'logarithmic',
                        title: {
                            display: true,
                            text: 'Time (ms)'
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Matrix Multiplication Performance Comparison'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                const value = context.parsed.y?.toFixed(2) || '';
                                return `${label}: ${value} ms`;
                            }
                        }
                    }
                }
            }
        });
    }
    
    // Create bar charts
    function createBarCharts() {
        const barChartsContainer = document.getElementById('barChartsContainer');
        barChartsContainer.innerHTML = '';
    
        const getImplementationColor = (implementation, alpha = 0.8) => {
            const colors = {
                'Naive': `rgba(255, 99, 132, ${alpha})`,
                'Shared Memory': `rgba(54, 162, 235, ${alpha})`,
                'Vectorized': `rgba(75, 192, 192, ${alpha})`
            };
            return colors[implementation] || `rgba(201, 203, 207, ${alpha})`;
        };
    
        const matrixSizes = [...new Set([...results.naive, ...results.sharedMemory, ...results.vectorized]
            .map(r => r.size))].sort((a, b) => a - b);
    
        matrixSizes.forEach(size => {
            const sizeResults = [
                ...results.naive.filter(r => r.size === size),
                ...results.sharedMemory.filter(r => r.size === size),
                ...results.vectorized.filter(r => r.size === size)
            ].sort((a, b) => a.time - b.time);
    
            if (sizeResults.length === 0) return;
    
            const chartWrapper = document.createElement('div');
            chartWrapper.className = 'bar-chart-wrapper';
            const canvas = document.createElement('canvas');
            chartWrapper.appendChild(canvas);
            barChartsContainer.appendChild(chartWrapper);
    
            const maxTime = Math.max(...sizeResults.map(r => r.time));
            const yAxisMax = Math.ceil(maxTime * 1.1);
    
            new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: sizeResults.map(r => {
                        const implementation = r.implementation;
                        const workgroupSize = r.workgroupSize.replace(',', 'x');
                        const tileSize = r.tileSize === 'N/A' ? '' : ` (Tile: ${r.tileSize.replace(',', 'x')})`;
                        const vectorized = r.implementation === 'Vectorized' ? ' (Vec)' : '';
                        return `${implementation} ${workgroupSize}${tileSize}${vectorized}`;
                    }),
                    datasets: [{
                        label: 'Execution Time',
                        data: sizeResults.map(r => r.time),
                        backgroundColor: sizeResults.map(r => getImplementationColor(r.implementation, 0.8)),
                        borderColor: sizeResults.map(r => getImplementationColor(r.implementation, 1)),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Performance for ${size}x${size} Matrix`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        subtitle: {
                            display: true,
                            text: 'Lower time is better',
                            padding: 10
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Time: ${context.raw.toFixed(2)} ms`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: yAxisMax,
                            title: {
                                display: true,
                                text: 'Time (ms)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Method & Sizes'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                }
            });
        });
    }

    window.addEventListener('load', initialize);
    </script>
</body>
</html>
