<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Multiplication Benchmark</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .tile {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-container {
            height: 500px;
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
        }
        .matrix-sizes {
            margin: 10px 0;
        }
        .config-section {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .config-section h4 {
            margin-top: 0;
        }
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .options-grid label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            white-space: nowrap;
        }
        #sizeCheckboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        #sizeCheckboxes label {
            white-space: nowrap;
        }
        .button-group {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            margin-left: 16px;
        }
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .small-button {
            padding: 4px 8px;
            font-size: 12px;
            background-color: #6c757d;
        }
        .bar-charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            padding: 10px;
        }
        .bar-chart-wrapper {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            height: 400px;
        }
        .implementation-selector {
            margin: 10px 0;
        }
        .implementation-selector label {
            margin-right: 15px;
        }
        .tile-options {
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        .tile-options.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .tile-size-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="tile">
            <h2>Matrix Multiplication Benchmark</h2>
            <div id="deviceInfo"></div>
        </div>
        
        <div class="tile">
            <h3>Configuration</h3>
            <div class="config-section">
                <div class="section-header">
                    <h4>Matrix Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleMatrixSizes('reset')">Reset</button>
                        <button class="small-button" onclick="handleMatrixSizes('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="sizeCheckboxes"></div>
            </div>
            
            <div class="config-section">
                <div class="section-header">
                    <h4>Workgroup Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleWorkgroups('reset')">Reset</button>
                        <button class="small-button" onclick="handleWorkgroups('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="workgroupSizes" class="options-grid"></div>
            </div>

            <div class="config-section">
                <div class="section-header">
                    <h4>Tile Sizes</h4>
                    <div class="button-group">
                        <button class="small-button" onclick="handleTileSizes('reset')">Reset</button>
                        <button class="small-button" onclick="handleTileSizes('selectAll')">Select All</button>
                    </div>
                </div>
                <div id="tileSizes" class="options-grid"></div>
            </div>

            <div class="config-section">
                <div class="implementation-selector">
                    <h4>Kernels:</h4>
                    <label>
                        <input type="checkbox" id="naiveImplementation" checked>
                        Naive
                    </label>
                    <label>
                        <input type="checkbox" id="sharedMemoryImplementation" checked>
                        Shared Memory Tiling
                    </label>
                </div>
            </div>

            <div class="config-section">
                <label for="iterations">Number of iterations:</label>
                <input type="number" id="iterations" value="1" min="1" max="100">
            </div>

            <div>
                <button id="generateMatrices">Generate Matrices</button>
                <button id="runBenchmark">Run Benchmark</button>
                <button id="downloadResults">Download Results</button>
            </div>
        </div>

        <div class="tile">
            <h3>Results</h3>
            <div id="resultsTable"></div>
        </div>

        <div class="tile">
            <h3>Performance Comparison</h3>
            <div class="chart-container">
                <canvas id="benchmarkChart"></canvas>
            </div>
        </div>

        <div class="tile">
            <h3>Performance by Matrix Size</h3>
            <div id="barChartsContainer" class="bar-charts-container">
            </div>
        </div>
    </div>

    <script>
    // Configuration
    const matrixSizes = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];

    // Generate workgroup sizes based on the specified logic
    const workgroupSizes = [];
    for (let x = 0; x <= 8; x++) {
        for (let y = 0; y <= 8; y++) {
            const xDim = Math.pow(2, x);
            const yDim = Math.pow(2, y);
            if (xDim * yDim <= 256) {
                workgroupSizes.push(`${xDim},${yDim}`);
            }
        }
    }

    let device;
    let generatedMatrices = {};
    let benchmarkChart;
    let results = {
        naive: [],
        sharedMemory: []
    };

    // Generate tile sizes for a given workgroup size
    function generateTileSizes(workgroupSize) {
        const [wx, wy] = workgroupSize.split(',').map(Number);
        const tileSizes = new Set();
        
        // Find the minimum dimension of the workgroup
        const minDimension = Math.min(wx, wy);
        
        // Get maximum allowed power of 2 that fits in the minimum dimension
        const maxPower = Math.floor(Math.log2(minDimension));
        
        // Generate square tiles (powers of 2)
        for (let p = 0; p <= maxPower; p++) {
            const tileSize = Math.pow(2, p);
            tileSizes.add(`${tileSize},${tileSize}`);
        }
    
        return Array.from(tileSizes);
    }

    // Validation function for tile size compatibility
    function isTileSizeCompatibleWithWorkgroup(tileSize, workgroupSize) {
        const [tileWidth, tileHeight] = tileSize.split(',').map(Number);
        const [workgroupWidth, workgroupHeight] = workgroupSize.split(',').map(Number);
        
        // Tile dimensions must be less than or equal to workgroup dimensions
        return tileWidth <= workgroupWidth && tileHeight <= workgroupHeight;
    }

    // Update tile size options based on selected workgroup
    function updateTileSizes() {
        const selectedWorkgroups = Array.from(document.querySelectorAll('#workgroupSizes input:checked'))
            .map(cb => cb.value);

        const tileSizesContainer = document.getElementById('tileSizes');
        const allTileSizes = new Set();

        selectedWorkgroups.forEach(workgroupSize => {
            generateTileSizes(workgroupSize).forEach(size => allTileSizes.add(size));
        });

        tileSizesContainer.innerHTML = Array.from(allTileSizes).sort((a, b) => {
            const [aSize] = a.split(',').map(Number);
            const [bSize] = b.split(',').map(Number);
            return aSize - bSize;
        }).map(size => `
            <label>
                <input type="checkbox" value="${size}" ${size === '16,16' ? 'checked' : ''}>
                ${size.replace(',', 'x')}
            </label>
        `).join('');
    }

    // Naive WGSL implementation
    function getNaiveWGSL(workgroupSize) {
        const [wx, wy] = workgroupSize.split(',').map(Number);
        return `
            @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
            @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
            @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
            @group(0) @binding(3) var<uniform> uniforms : Uniforms;

            struct Uniforms {
                N : u32,
                alpha : f32,
                beta : f32,
            }

            @compute @workgroup_size(${wx}, ${wy})
            fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                let N = uniforms.N;
                let row = global_id.y;
                let col = global_id.x;

                if (row >= N || col >= N) {
                    return;
                }

                let row_offset = row * N;
                var sum: f32 = 0.0;

                for (var k = 0u; k < N; k = k + 1u) {
                    let a = matrixA[row_offset + k];
                    let b = matrixB[k * N + col];
                    sum = sum + a * b;
                }

                matrixC[row_offset + col] = uniforms.alpha * sum + uniforms.beta * matrixC[row_offset + col];
            }
        `;
    }

    // Shared Memory Tiling WGSL implementation
    function getNaiveDecoupledSharedMemoryWGSL(workgroupSize, tileSize) {
        const [workgroupRows, workgroupCols] = workgroupSize.split(',').map(Number);
        const [tileRows, tileCols] = tileSize.split(',').map(Number);
        
        return `
            @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
            @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
            @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
            @group(0) @binding(3) var<uniform> uniforms : Uniforms;

            struct Uniforms {
                N : u32,
                alpha : f32,
                beta : f32,
            }

            const TILE_SIZE = ${tileRows}u;  // Using square tiles for simplicity
            const WG_SIZE = ${workgroupRows}u;  // Using square workgroups

            var<workgroup> tileA: array<f32, ${workgroupRows * workgroupCols}>;
            var<workgroup> tileB: array<f32, ${workgroupRows * workgroupCols}>;

            @compute @workgroup_size(${workgroupRows}, ${workgroupCols})
            fn main(
                @builtin(global_invocation_id) global_id: vec3<u32>,
                @builtin(local_invocation_id) local_id: vec3<u32>,
                @builtin(workgroup_id) workgroup_id: vec3<u32>
            ) {
                let N = uniforms.N;
                let row = global_id.y;
                let col = global_id.x;
                let localRow = local_id.y;
                let localCol = local_id.x;
                let localIdx = localRow * WG_SIZE + localCol;
                
                var sum = 0.0;
                
                // Number of tiles needed for the full matrix multiplication
                let numTiles = (N + TILE_SIZE - 1u) / TILE_SIZE;

                for (var tile = 0u; tile < numTiles; tile = tile + 1u) {
		// Load current tile of A and B into shared memory
                    let tileOffset = tile * TILE_SIZE;

                    // Each thread loads its corresponding element
                    if (row < N && (tileOffset + localCol) < N) {
                        tileA[localIdx] = matrixA[row * N + tileOffset + localCol];
                    } else {
                        tileA[localIdx] = 0.0;
                    }

                    if ((tileOffset + localRow) < N && col < N) {
                        tileB[localIdx] = matrixB[(tileOffset + localRow) * N + col];
                    } else {
                        tileB[localIdx] = 0.0;
                    }

                    workgroupBarrier();

                    // Compute partial dot product using the loaded tiles
                    if (row < N && col < N) {
                        for (var k = 0u; k < TILE_SIZE; k = k + 1u) {
                            let aIndex = localRow * WG_SIZE + k;
                            let bIndex = k * WG_SIZE + localCol;

                            if (tileOffset + k < N) {
                                sum = sum + tileA[aIndex] * tileB[bIndex];
                            }
                        }
                    }

                    workgroupBarrier();
                }

                // Write final result
                if (row < N && col < N) {
                    let index = row * N + col;
                    matrixC[index] = uniforms.alpha * sum + uniforms.beta * matrixC[index];
                }
            }
        `;
    }

    // Handle matrix size selection buttons
    function handleMatrixSizes(action) {
        const checkboxes = document.querySelectorAll('#sizeCheckboxes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = action === 'selectAll';
        });
    }

    // Handle workgroup selection buttons
    function handleWorkgroups(action) {
        const checkboxes = document.querySelectorAll('#workgroupSizes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = action === 'selectAll';
        });
        updateTileSizes();
    }

    // Handle tile size selection buttons
    function handleTileSizes(action) {
        const checkboxes = document.querySelectorAll('#tileSizes input[type="checkbox"]');
        checkboxes.forEach(checkbox => {
            checkbox.checked = action === 'selectAll';
        });
    }

    // Initialize WebGPU
    async function initWebGPU() {
        if (!navigator.gpu) {
            throw new Error("WebGPU not supported");
        }
        const adapter = await navigator.gpu.requestAdapter();
        device = await adapter.requestDevice();
        return device;
    }

    // Create buffer helper function
    function createBuffer(data, usage) {
        const buffer = device.createBuffer({
            size: data.byteLength,
            usage: usage,
            mappedAtCreation: true,
        });
        new Float32Array(buffer.getMappedRange()).set(data);
        buffer.unmap();
        return buffer;
    }

    // Generate matrices
    async function generateMatrices(sizes) {
        for (const N of sizes) {
            const matrixSize = N * N;
            const matrixA = new Float32Array(matrixSize);
            const matrixB = new Float32Array(matrixSize);

            for (let i = 0; i < matrixSize; i++) {
                matrixA[i] = Math.random();
                matrixB[i] = Math.random();
            }

            const bufferA = createBuffer(matrixA, GPUBufferUsage.STORAGE);
            const bufferB = createBuffer(matrixB, GPUBufferUsage.STORAGE);

            generatedMatrices[N] = { bufferA, bufferB, matrixA, matrixB };
        }
    }

    // Verify matrix multiplication
    function verifyMatrixMultiplication(matrixA, matrixB, resultMatrix, N, alpha, beta) {
        for (let check = 0; check < 5; check++) {
            const row = Math.floor(Math.random() * N);
            const col = Math.floor(Math.random() * N);
            let expected = 0;
            for (let i = 0; i < N; i++) {
                expected += matrixA[row * N + i] * matrixB[i * N + col];
            }
            expected = alpha * expected + beta * 0;
            const actual = resultMatrix[row * N + col];
            const relativeError = Math.abs((expected - actual) / expected);
            if (relativeError > 1e-5) {
                return false;
            }
        }
        return true;
    }

    // Run benchmark
    async function runBenchmark(N, workgroupSize, implementation = 'naive', tileSize = null) {
        const shaderModule = device.createShaderModule({
            code: implementation === 'naive'
                ? getNaiveWGSL(workgroupSize)
                : getNaiveDecoupledSharedMemoryWGSL(workgroupSize, tileSize || workgroupSize)
        });

        const { bufferA, bufferB, matrixA, matrixB } = generatedMatrices[N];
        const matrixSize = N * N;
        const resultMatrix = new Float32Array(matrixSize).fill(0);
        const bufferC = createBuffer(resultMatrix, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);

        const uniformBuffer = device.createBuffer({
            size: 16,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const uniformData = new ArrayBuffer(16);
        new Uint32Array(uniformData, 0, 1)[0] = N;
        new Float32Array(uniformData, 4, 1)[0] = 1.0;
        new Float32Array(uniformData, 8, 1)[0] = 0.0;
        device.queue.writeBuffer(uniformBuffer, 0, uniformData);

        const bindGroupLayout = device.createBindGroupLayout({
            entries: [
                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
            ],
        });

        const bindGroup = device.createBindGroup({
            layout: bindGroupLayout,
            entries: [
                { binding: 0, resource: { buffer: bufferA } },
                { binding: 1, resource: { buffer: bufferB } },
                { binding: 2, resource: { buffer: bufferC } },
                { binding: 3, resource: { buffer: uniformBuffer } },
            ],
        });

        const pipeline = device.createComputePipeline({
            layout: device.createPipelineLayout({
                bindGroupLayouts: [bindGroupLayout],
            }),
            compute: {
                module: shaderModule,
                entryPoint: "main",
            },
        });

        const [wx, wy] = workgroupSize.split(',').map(Number);
        const commandEncoder = device.createCommandEncoder();
        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.dispatchWorkgroups(Math.ceil(N / wx), Math.ceil(N / wy));
        passEncoder.end();

        const startTime = performance.now();
        device.queue.submit([commandEncoder.finish()]);
        await device.queue.onSubmittedWorkDone();
        const endTime = performance.now();

        const resultReadBuffer = device.createBuffer({
            size: bufferC.size,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        });

        const readbackEncoder = device.createCommandEncoder();
        readbackEncoder.copyBufferToBuffer(bufferC, 0, resultReadBuffer, 0, bufferC.size);
        device.queue.submit([readbackEncoder.finish()]);

        await resultReadBuffer.mapAsync(GPUMapMode.READ);
        const resultArray = new Float32Array(resultReadBuffer.getMappedRange());
        const isVerified = verifyMatrixMultiplication(matrixA, matrixB, resultArray, N, 1.0, 0.0);
        resultReadBuffer.unmap();

        return {
            time: endTime - startTime,
            verified: isVerified
        };
    }

    // Perform benchmark with validation
    async function performBenchmark() {
        const iterations = parseInt(document.getElementById('iterations').value);
        const selectedSizes = Array.from(document.querySelectorAll('#sizeCheckboxes input:checked'))
            .map(cb => parseInt(cb.value));

        const selectedWorkgroups = Array.from(document.querySelectorAll('#workgroupSizes input:checked'))
            .map(cb => cb.value);

        const selectedTileSizes = Array.from(document.querySelectorAll('#tileSizes input:checked'))
            .map(cb => cb.value);

        const runNaive = document.getElementById('naiveImplementation').checked;
        const runSharedMemory = document.getElementById('sharedMemoryImplementation').checked;

        if (selectedWorkgroups.length === 0) {
            alert('Please select at least one workgroup size');
            return;
        }

        if (runSharedMemory && selectedTileSizes.length === 0) {
            alert('Please select at least one tile size for Shared Memory implementation');
            return;
        }

        if (!runNaive && !runSharedMemory) {
            alert('Please select at least one kernel');
            return;
        }

        // Validate tile size compatibility with workgroups
        const compatibleConfigs = [];
        if (runSharedMemory) {
            for (const workgroupSize of selectedWorkgroups) {
                const compatibleTileSizes = selectedTileSizes.filter(tileSize =>
                    isTileSizeCompatibleWithWorkgroup(tileSize, workgroupSize)
                );
                if (compatibleTileSizes.length > 0) {
                    compatibleConfigs.push({
                        workgroupSize,
                        tileSizes: compatibleTileSizes
                    });
                }
            }

            if (compatibleConfigs.length === 0) {
                alert('No compatible workgroup and tile size combinations found. Please adjust your selection.');
                return;
            }
        }

        results = { naive: [], sharedMemory: [] };

        const resultsTable = document.getElementById('resultsTable');
        resultsTable.innerHTML = `
            <table>
                <thead>
                    <tr>
                        <th>Implementation</th>
                        <th>Matrix Size</th>
                        <th>Workgroup Size</th>
                        <th>Tile Size</th>
                        <th>Average Time (ms)</th>
                        <th>GFLOPS</th>
                        <th>Verified</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        `;
        const tbody = resultsTable.querySelector('tbody');

        for (const size of selectedSizes) {
            for (const workgroupSize of selectedWorkgroups) {
                if (runNaive) {
                    await runBenchmark(size, workgroupSize, 'naive'); // Warm-up
                    let totalTimeNaive = 0;
                    let allVerifiedNaive = true;

                    for (let i = 0; i < iterations; i++) {
                        const result = await runBenchmark(size, workgroupSize, 'naive');
                        totalTimeNaive += result.time;
                        allVerifiedNaive = allVerifiedNaive && result.verified;
                    }

                    const avgTimeNaive = totalTimeNaive / iterations;
                    const gflopsNaive = (2 * size * size * size) / (avgTimeNaive * 1e6);

                    results.naive.push({
                        implementation: 'Naive',
                        size,
                        workgroupSize,
                        tileSize: 'N/A',
                        time: parseFloat(avgTimeNaive.toFixed(2)),
                        gflops: parseFloat(gflopsNaive.toFixed(2)),
                        verified: allVerifiedNaive
                    });

                    tbody.insertRow().innerHTML = `
                        <td>Naive</td>
                        <td>${size}x${size}</td>
                        <td>${workgroupSize.replace(',', 'x')}</td>
                        <td>N/A</td>
                        <td>${avgTimeNaive.toFixed(2)}</td>
                        <td>${gflopsNaive.toFixed(2)}</td>
                        <td>${allVerifiedNaive ? '✓' : '✗'}</td>
                    `;
                }

                if (runSharedMemory) {
                    const config = compatibleConfigs.find(c => c.workgroupSize === workgroupSize);
                    if (config) {
                        for (const tileSize of config.tileSizes) {
                            // Warm-up
                            await runBenchmark(size, workgroupSize, 'shared', tileSize);
                            let totalTimeShared = 0;
                            let allVerifiedShared = true;

                            for (let i = 0; i < iterations; i++) {
                                const result = await runBenchmark(size, workgroupSize, 'shared', tileSize);
                                totalTimeShared += result.time;
                                allVerifiedShared = allVerifiedShared && result.verified;
                            }

                            const avgTimeShared = totalTimeShared / iterations;
                            const gflopsShared = (2 * size * size * size) / (avgTimeShared * 1e6);

                            results.sharedMemory.push({
                                implementation: 'Shared Memory',
                                size,
                                workgroupSize,
                                tileSize,
                                time: parseFloat(avgTimeShared.toFixed(2)),
                                gflops: parseFloat(gflopsShared.toFixed(2)),
                                verified: allVerifiedShared
                            });

                            tbody.insertRow().innerHTML = `
                                <td>Shared Memory</td>
                                <td>${size}x${size}</td>
                                <td>${workgroupSize.replace(',', 'x')}</td>
                                <td>${tileSize.replace(',', 'x')}</td>
                                <td>${avgTimeShared.toFixed(2)}</td>
                                <td>${gflopsShared.toFixed(2)}</td>
                                <td>${allVerifiedShared ? '✓' : '✗'}</td>
                            `;
                        }
                    }
                }
            }
        }

        updateChart();
        createBarCharts();
    }

    // Download results
    function downloadResults() {
        const csv = [
            'Implementation,Matrix Size,Workgroup Size,Tile Size,Time (ms),GFLOPS,Verified'
        ];

        [...results.naive, ...results.sharedMemory].forEach(result => {
            csv.push(`${result.implementation},${result.size},${result.workgroupSize},${result.tileSize},${result.time.toFixed(2)},${result.gflops.toFixed(2)},${result.verified}`);
        });

        const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.setAttribute('href', url);
        a.setAttribute('download', 'benchmark_results.csv');
        a.click();
    }

    // Update device info
    async function updateDeviceInfo() {
        const deviceInfoElement = document.getElementById("deviceInfo");
        try {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported on this browser.");
            }
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                throw new Error("No appropriate GPUAdapter found.");
            }
            const adapterInfo = await adapter.requestAdapterInfo();

            deviceInfoElement.innerHTML = `
                <strong>GPU Vendor:</strong> ${adapterInfo.vendor}<br>
                <strong>GPU Architecture:</strong> ${adapterInfo.architecture}<br>
                <strong>Description:</strong> ${adapterInfo.description || 'Not available'}<br>
                <strong>Device:</strong> ${navigator.platform}<br>
                <strong>Browser:</strong> ${navigator.userAgent}
            `;
        } catch (error) {
            deviceInfoElement.innerHTML = `
                <strong>Error:</strong> ${error.message}<br>
                <strong>Device:</strong> ${navigator.platform}<br>
                <strong>Browser:</strong> ${navigator.userAgent}
            `;
        }
    }

    // Initialize
    async function initialize() {
        try {
            await initWebGPU();
            await updateDeviceInfo();

            // Initialize matrix size checkboxes
            const sizesContainer = document.getElementById('sizeCheckboxes');
            sizesContainer.innerHTML = matrixSizes.map(size => `
                <label>
                    <input type="checkbox" value="${size}" checked>
                    ${size}x${size}
                </label>
            `).join(' ');

            // Initialize workgroup size checkboxes
            const workgroupsContainer = document.getElementById('workgroupSizes');
            workgroupsContainer.innerHTML = workgroupSizes.map(size => `
                <label>
                    <input type="checkbox" value="${size}" ${size === '16,16' ? 'checked' : ''}>
                    ${size.replace(',', 'x')}
                </label>
            `).join('');

            // Add event listener for workgroup size changes
            document.querySelectorAll('#workgroupSizes input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', updateTileSizes);
            });

            // Initial update of tile sizes
            updateTileSizes();

            // Event listeners for buttons
            document.getElementById('generateMatrices').addEventListener('click', async () => {
                const selectedSizes = Array.from(document.querySelectorAll('#sizeCheckboxes input:checked'))
                    .map(cb => parseInt(cb.value));
                if (selectedSizes.length === 0) {
                    alert('Please select at least one matrix size');
                    return;
                }
                try {
                    document.getElementById('generateMatrices').disabled = true;
                    document.getElementById('generateMatrices').textContent = 'Generating...';
                    await generateMatrices(selectedSizes);
                    alert('Matrices generated successfully!');
                } catch (error) {
                    console.error('Error generating matrices:', error);
                    alert('Error generating matrices: ' + error.message);
                } finally {
                    document.getElementById('generateMatrices').disabled = false;
                    document.getElementById('generateMatrices').textContent = 'Generate Matrices';
                }
            });

            document.getElementById('runBenchmark').addEventListener('click', async () => {
                try {
                    document.getElementById('runBenchmark').disabled = true;
                    document.getElementById('runBenchmark').textContent = 'Running...';
                    await performBenchmark();
                } catch (error) {
                    console.error('Error running benchmark:', error);
                    alert('Error running benchmark: ' + error.message);
                } finally {
                    document.getElementById('runBenchmark').disabled = false;
                    document.getElementById('runBenchmark').textContent = 'Run Benchmark';
                }
            });

            document.getElementById('downloadResults').addEventListener('click', downloadResults);

        } catch (error) {
            console.error('Initialization failed:', error);
            alert('Failed to initialize WebGPU: ' + error.message);
        }
    }

    // Create bar charts
    function createBarCharts() {
        const barChartsContainer = document.getElementById('barChartsContainer');
        barChartsContainer.innerHTML = '';

        const matrixSizes = [...new Set([...results.naive, ...results.sharedMemory].map(r => r.size))].sort((a, b) => a - b);

        matrixSizes.forEach(size => {
            const naiveResults = results.naive.filter(r => r.size === size);
            const sharedMemoryResults = results.sharedMemory.filter(r => r.size === size);

            const allResults = [...naiveResults, ...sharedMemoryResults];
            allResults.sort((a, b) => a.time - b.time);

            if (allResults.length === 0) return;

            const chartWrapper = document.createElement('div');
            chartWrapper.className = 'bar-chart-wrapper';
            const canvas = document.createElement('canvas');
            chartWrapper.appendChild(canvas);
            barChartsContainer.appendChild(chartWrapper);

            const maxTime = Math.max(...allResults.map(r => r.time));
            const yAxisMax = Math.ceil(maxTime * 1.1);

            new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: allResults.map(r => {
                        const implementation = r.implementation;
                        const workgroupSize = r.workgroupSize.replace(',', 'x');
                        const tileSize = r.tileSize === 'N/A' ? '' : ` (Tile: ${r.tileSize.replace(',', 'x')})`;
                        return `${implementation} ${workgroupSize}${tileSize}`;
                    }),
                    datasets: [{
                        label: 'Execution Time',
                        data: allResults.map(r => r.time),
                        backgroundColor: allResults.map(r =>
                            r.implementation === 'Shared Memory' ? 'rgba(54, 162, 235, 0.8)' : 'rgba(255, 99, 132, 0.8)'
                        ),
                        borderColor: allResults.map(r =>
                            r.implementation === 'Shared Memory' ? 'rgba(54, 162, 235, 1)' : 'rgba(255, 99, 132, 1)'
                        ),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Performance for ${size}x${size} Matrix`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        subtitle: {
                            display: true,
                            text: 'Lower time is better',
                            padding: 10
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: yAxisMax,
                            title: {
                                display: true,
                                text: 'Time (ms)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Method & Sizes'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                }
            });
        });
    }

    // Update line chart
    function updateChart() {
        const ctx = document.getElementById('benchmarkChart').getContext('2d');

        if (benchmarkChart) {
            benchmarkChart.destroy();
        }

        const datasets = [];
        const colors = [
            'rgb(75, 192, 192)', 'rgb(255, 99, 132)', 'rgb(54, 162, 235)',
            'rgb(255, 206, 86)', 'rgb(153, 102, 255)', 'rgb(255, 159, 64)'
        ];

        let colorIndex = 0;

        // Add naive implementation datasets
        const naiveWorkgroupSizes = [...new Set(results.naive.map(r => r.workgroupSize))];
        naiveWorkgroupSizes.forEach(wg => {
            const naiveResults = results.naive.filter(r => r.workgroupSize === wg);
            if (naiveResults.length > 0) {
                datasets.push({
                    label: `Naive WG ${wg.replace(',', 'x')}`,
                    data: naiveResults.map(r => r.time),
                    borderColor: colors[colorIndex % colors.length],
                    tension: 0.1
                });
                colorIndex++;
            }
        });

        // Add shared memory implementation datasets
        const sharedMemoryConfigs = [...new Set(results.sharedMemory.map(r =>
            `${r.workgroupSize},${r.tileSize}`
        ))];

        sharedMemoryConfigs.forEach(config => {
            const [workgroupSize, tileSize] = config.split(',', 2);
            const sharedResults = results.sharedMemory.filter(r =>
                r.workgroupSize === workgroupSize && r.tileSize === tileSize
            );
            if (sharedResults.length > 0) {
                datasets.push({
                    label: `Shared Mem WG ${workgroupSize.replace(',', 'x')} Tile ${tileSize.replace(',', 'x')}`,
                    data: sharedResults.map(r => r.time),
                    borderColor: colors[colorIndex % colors.length],
                    borderDash: [5, 5],
                    tension: 0.1
                });
                colorIndex++;
            }
        });

        const matrixSizes = [...new Set([...results.naive, ...results.sharedMemory].map(r => r.size))].sort((a, b) => a - b);

        benchmarkChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: matrixSizes.map(size => `${size}x${size}`),
                datasets: datasets
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Matrix Size'
                        }
                    },
                    y: {
                        type: 'logarithmic',
                        title: {
                            display: true,
                            text: 'Time (ms)'
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Matrix Multiplication Performance Comparison'
                    }
                }
            }
        });
    }

    window.addEventListener('load', initialize);
    </script>
</body>
</html>
