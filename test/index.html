<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Multiplication Benchmark</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .tile {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-container {
            height: 500px;
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
        }
        .matrix-sizes {
            margin: 10px 0;
        }
        .config-section {
            margin: 15px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .config-section h4 {
            margin-top: 0;
        }
        .workgroup-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        .workgroup-options label {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #sizeCheckboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        #sizeCheckboxes label {
            white-space: nowrap;
        }
        .error {
            color: red;
            font-weight: bold;
            padding: 10px;
            margin: 10px 0;
            background-color: #ffe6e6;
            border-radius: 4px;
        }
        .verification-success {
            color: green;
            font-weight: bold;
        }
        .verification-failed {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="tile">
            <h2>Matrix Multiplication Benchmark</h2>
            <div id="deviceInfo"></div>
        </div>
        
        <div class="tile">
            <h3>Configuration</h3>
            <div class="config-section">
                <h4>Matrix Sizes</h4>
                <div id="sizeCheckboxes"></div>
            </div>
            
            <div class="config-section">
                <h4>Naive Implementation Workgroups</h4>
                <div id="naiveWorkgroups" class="workgroup-options"></div>
            </div>
            
            <div class="config-section">
                <h4>Decoupled Implementation Workgroups</h4>
                <div id="decoupledWorkgroups" class="workgroup-options"></div>
            </div>

            <div class="config-section">
                <label for="iterations">Number of iterations:</label>
                <input type="number" id="iterations" value="10" min="1" max="100">
            </div>

            <div>
                <button id="generateMatrices">Generate Matrices</button>
                <button id="runBenchmark">Run Benchmark</button>
                <button id="downloadResults">Download Results</button>
            </div>
        </div>

        <div class="tile">
            <h3>Results</h3>
            <div id="resultsTable"></div>
        </div>

        <div class="tile">
            <h3>Performance Comparison</h3>
            <div class="chart-container">
                <canvas id="benchmarkChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const matrixSizes = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
        const naiveWorkgroupSizes = [
            '8,8', '16,16', '32,32'  // Square workgroups for naive implementation
        ];
        const decoupledWorkgroupSizes = [
		'2,128', '4,64', '8,32', '16,16', '32,8', '64,4', '128,2'
        ];

        let device;
        let generatedMatrices = {};
        let benchmarkChart;
        let results = {
            naive: [],
            decoupled: []
        };

	// Naive WGSL implementation
        function getNaiveWGSL(workgroupSize) {
            const [wx, wy] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;

                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }

                @compute @workgroup_size(${wx}, ${wy})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                    let N = uniforms.N;
                    let row = global_id.y;
                    let col = global_id.x;

                    if (row >= N || col >= N) {
                        return;
                    }

                    let row_offset = row * N;
                    var sum: f32 = 0.0;

                    for (var k = 0u; k < N; k = k + 1u) {
                        let a = matrixA[row_offset + k];
                        let b = matrixB[k * N + col];
                        sum = sum + a * b;
                    }

                    matrixC[row_offset + col] = uniforms.alpha * sum + uniforms.beta * matrixC[row_offset + col];
                }
            `;
        }

        // Decoupled WGSL implementation
        function getNaiveDecoupledWGSL(workgroupSize) {
            const [wx, wy] = workgroupSize.split(',').map(Number);
            return `
                @group(0) @binding(0) var<storage, read> matrixA : array<f32>;
                @group(0) @binding(1) var<storage, read> matrixB : array<f32>;
                @group(0) @binding(2) var<storage, read_write> matrixC : array<f32>;
                @group(0) @binding(3) var<uniform> uniforms : Uniforms;

                struct Uniforms {
                    N : u32,
                    alpha : f32,
                    beta : f32,
                }

                @compute @workgroup_size(${wx}, ${wy})
                fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
                    let N = uniforms.N;
                    let row = global_id.y;
                    let col = global_id.x;

                    if (row >= N || col >= N) {
                        return;
                    }

                    let row_offset = row * N;
                    var sum: f32 = 0.0;

                    for (var k = 0u; k < N; k = k + 1u) {
                        let a = matrixA[row_offset + k];
                        let b = matrixB[k * N + col];
                        sum = sum + a * b;
                    }

                    matrixC[row_offset + col] = uniforms.alpha * sum + uniforms.beta * matrixC[row_offset + col];
                }
            `;
        }

        // Initialize WebGPU
        async function initWebGPU() {
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported");
            }
            const adapter = await navigator.gpu.requestAdapter();
            device = await adapter.requestDevice();
            return device;
        }

        // Create buffer helper function
        function createBuffer(data, usage) {
            const buffer = device.createBuffer({
                size: data.byteLength,
                usage: usage,
                mappedAtCreation: true,
            });
            new Float32Array(buffer.getMappedRange()).set(data);
            buffer.unmap();
            return buffer;
        }

        // Generate matrices
        async function generateMatrices(sizes) {
            for (const N of sizes) {
                const matrixSize = N * N;
                const matrixA = new Float32Array(matrixSize);
                const matrixB = new Float32Array(matrixSize);

                for (let i = 0; i < matrixSize; i++) {
                    matrixA[i] = Math.random();
                    matrixB[i] = Math.random();
                }

                const bufferA = createBuffer(matrixA, GPUBufferUsage.STORAGE);
                const bufferB = createBuffer(matrixB, GPUBufferUsage.STORAGE);

                generatedMatrices[N] = { bufferA, bufferB, matrixA, matrixB };
            }
        }

        // Verify matrix multiplication
        function verifyMatrixMultiplication(matrixA, matrixB, resultMatrix, N, alpha, beta, numChecks = 20) {
            for (let check = 0; check < numChecks; check++) {
                const row = Math.floor(Math.random() * N);
                const col = Math.floor(Math.random() * N);
                let expected = 0;
                for (let i = 0; i < N; i++) {
                    expected += matrixA[row * N + i] * matrixB[i * N + col];
                }
                expected = alpha * expected + beta * 0;
                const actual = resultMatrix[row * N + col];
                const relativeError = Math.abs((expected - actual) / expected);
                if (relativeError > 1e-5) {
                    console.error(`Verification failed at [${row}, ${col}]:`);
                    console.error(`Expected: ${expected}, Actual: ${actual}`);
                    return false;
                }
            }
            return true;
        }

        // Run benchmark
        async function runBenchmark(N, implementation, workgroupSize) {
            const shaderModule = device.createShaderModule({
                code: implementation === 'naive'
                    ? getNaiveWGSL(workgroupSize)
                    : getNaiveDecoupledWGSL(workgroupSize)
            });

            const { bufferA, bufferB, matrixA, matrixB } = generatedMatrices[N];
            const matrixSize = N * N;
            const resultMatrix = new Float32Array(matrixSize).fill(0);
            const bufferC = createBuffer(resultMatrix, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);

            const uniformBuffer = device.createBuffer({
                size: 16,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });

            const uniformData = new ArrayBuffer(16);
            new Uint32Array(uniformData, 0, 1)[0] = N;
            new Float32Array(uniformData, 4, 1)[0] = 1.0;
            new Float32Array(uniformData, 8, 1)[0] = 0.0;
            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            const bindGroupLayout = device.createBindGroupLayout({
                entries: [
                    { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                    { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                    { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
                    { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
                ],
            });

            const bindGroup = device.createBindGroup({
                layout: bindGroupLayout,
                entries: [
                    { binding: 0, resource: { buffer: bufferA } },
                    { binding: 1, resource: { buffer: bufferB } },
                    { binding: 2, resource: { buffer: bufferC } },
                    { binding: 3, resource: { buffer: uniformBuffer } },
                ],
            });

            const pipeline = device.createComputePipeline({
                layout: device.createPipelineLayout({
                    bindGroupLayouts: [bindGroupLayout],
                }),
                compute: {
                    module: shaderModule,
                    entryPoint: "main",
                },
            });

            const commandEncoder = device.createCommandEncoder();
            const passEncoder = commandEncoder.beginComputePass();
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);

            const [x, y] = workgroupSize.split(',').map(Number);
            passEncoder.dispatchWorkgroups(Math.ceil(N / x), Math.ceil(N / y));
            passEncoder.end();

            const startTime = performance.now();
            device.queue.submit([commandEncoder.finish()]);
            await device.queue.onSubmittedWorkDone();
            const endTime = performance.now();

            const resultReadBuffer = device.createBuffer({
                size: bufferC.size,
                usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            });

            const readbackEncoder = device.createCommandEncoder();
            readbackEncoder.copyBufferToBuffer(bufferC, 0, resultReadBuffer, 0, bufferC.size);
            device.queue.submit([readbackEncoder.finish()]);

            await resultReadBuffer.mapAsync(GPUMapMode.READ);
            const resultArray = new Float32Array(resultReadBuffer.getMappedRange());
            const isVerified = verifyMatrixMultiplication(matrixA, matrixB, resultArray, N, 1.0, 0.0);
            resultReadBuffer.unmap();

            return {
                time: endTime - startTime,
                verified: isVerified,
                workgroupSize: workgroupSize
            };
        }
	
	// Perform benchmark
        async function performBenchmark() {
            const iterations = parseInt(document.getElementById('iterations').value);
            const selectedSizes = Array.from(document.querySelectorAll('#sizeCheckboxes input:checked'))
                .map(cb => parseInt(cb.value));

            const selectedNaiveWorkgroups = Array.from(document.querySelectorAll('#naiveWorkgroups input:checked'))
                .map(cb => cb.value);
            const selectedDecoupledWorkgroups = Array.from(document.querySelectorAll('#decoupledWorkgroups input:checked'))
                .map(cb => cb.value);

            if (selectedNaiveWorkgroups.length === 0 || selectedDecoupledWorkgroups.length === 0) {
                alert('Please select at least one workgroup size for each implementation');
                return;
            }

            results = {
                naive: [],
                decoupled: []
            };

            const resultsTable = document.getElementById('resultsTable');
            resultsTable.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Matrix Size</th>
                            <th>Implementation</th>
                            <th>Workgroup Size</th>
                            <th>Average Time (ms)</th>
                            <th>GFLOPS</th>
                            <th>Verified</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            `;
            const tbody = resultsTable.querySelector('tbody');

            for (const size of selectedSizes) {
                // Benchmark naive implementation with selected workgroup sizes
                for (const workgroupSize of selectedNaiveWorkgroups) {
                    // Warm-up run
                    await runBenchmark(size, 'naive', workgroupSize);

                    let totalTime = 0;
                    let allVerified = true;

                    for (let i = 0; i < iterations; i++) {
                        const result = await runBenchmark(size, 'naive', workgroupSize);
                        totalTime += result.time;
                        allVerified = allVerified && result.verified;
                    }

                    const avgTime = totalTime / iterations;
                    const gflops = (2 * size * size * size) / (avgTime * 1e6);

                    results.naive.push({
                        size,
                        workgroupSize,
                        time: avgTime,
                        gflops,
                        verified: allVerified
                    });

                    const verificationClass = allVerified ? 'verification-success' : 'verification-failed';
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${size}x${size}</td>
                        <td>naive</td>
                        <td>${workgroupSize}</td>
                        <td>${avgTime.toFixed(2)}</td>
                        <td>${gflops.toFixed(2)}</td>
                        <td class="${verificationClass}">${allVerified ? '✓' : '✗'}</td>
                    `;
                }

                // Benchmark decoupled implementation with selected workgroup sizes
                for (const workgroupSize of selectedDecoupledWorkgroups) {
                    // Warm-up run
                    await runBenchmark(size, 'decoupled', workgroupSize);

                    let totalTime = 0;
                    let allVerified = true;

                    for (let i = 0; i < iterations; i++) {
                        const result = await runBenchmark(size, 'decoupled', workgroupSize);
                        totalTime += result.time;
                        allVerified = allVerified && result.verified;
                    }

                    const avgTime = totalTime / iterations;
                    const gflops = (2 * size * size * size) / (avgTime * 1e6);

                    results.decoupled.push({
                        size,
                        workgroupSize,
                        time: avgTime,
                        gflops,
                        verified: allVerified
                    });

                    const verificationClass = allVerified ? 'verification-success' : 'verification-failed';
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${size}x${size}</td>
                        <td>decoupled</td>
                        <td>${workgroupSize}</td>
                        <td>${avgTime.toFixed(2)}</td>
                        <td>${gflops.toFixed(2)}</td>
                        <td class="${verificationClass}">${allVerified ? '✓' : '✗'}</td>
                    `;
                }
            }

            updateChart();
        }

        // Update chart
        function updateChart() {
            const ctx = document.getElementById('benchmarkChart').getContext('2d');

            if (benchmarkChart) {
                benchmarkChart.destroy();
            }

            // Group results by implementation and workgroup size
            const datasets = [];
            const colors = [
                'rgb(75, 192, 192)', 'rgb(255, 99, 132)', 'rgb(54, 162, 235)',
                'rgb(255, 206, 86)', 'rgb(153, 102, 255)', 'rgb(255, 159, 64)',
                'rgb(75, 192, 100)', 'rgb(255, 99, 71)', 'rgb(54, 162, 200)',
                'rgb(128, 0, 0)', 'rgb(0, 128, 0)', 'rgb(0, 0, 128)',
                'rgb(128, 128, 0)', 'rgb(128, 0, 128)', 'rgb(0, 128, 128)'
            ];

            let colorIndex = 0;
            ['naive', 'decoupled'].forEach(impl => {
                const workgroupSizes = [...new Set(results[impl].map(r => r.workgroupSize))];
                workgroupSizes.forEach(wg => {
                    const filteredResults = results[impl].filter(r => r.workgroupSize === wg);
                    datasets.push({
                        label: `${impl} (${wg.replace(',', 'x')})`,
                        data: filteredResults.map(r => r.time),
                        borderColor: colors[colorIndex % colors.length],
                        tension: 0.1
                    });
                    colorIndex++;
                });
            });

            benchmarkChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [...new Set(results.naive.map(r => `${r.size}x${r.size}`))],
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Matrix Size'
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: 'Time (ms)'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Matrix Multiplication Performance Comparison'
                        }
                    }
                }
            });
        }

        // Download results
        function downloadResults() {
            const csv = [
                'Matrix Size,Implementation,Workgroup Size,Time (ms),GFLOPS,Verified'
            ];

            ['naive', 'decoupled'].forEach(impl => {
                results[impl].forEach(result => {
                    csv.push(`${result.size},${impl},${result.workgroupSize},${result.time.toFixed(2)},${result.gflops.toFixed(2)},${result.verified}`);
                });
            });

            const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', 'benchmark_results.csv');
            a.click();
        }

        // Update device info
        async function updateDeviceInfo() {
            const deviceInfoElement = document.getElementById("deviceInfo");
            try {
                if (!navigator.gpu) {
                    throw new Error("WebGPU not supported on this browser.");
                }
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error("No appropriate GPUAdapter found.");
                }
                const adapterInfo = await adapter.requestAdapterInfo();

                deviceInfoElement.innerHTML = `
                    <strong>GPU Vendor:</strong> ${adapterInfo.vendor}<br>
                    <strong>GPU Architecture:</strong> ${adapterInfo.architecture}<br>
                    <strong>Description:</strong> ${adapterInfo.description || 'Not available'}<br>
                    <strong>Device:</strong> ${navigator.platform}<br>
                    <strong>Browser:</strong> ${navigator.userAgent}
                `;
            } catch (error) {
                deviceInfoElement.innerHTML = `
                    <strong>Error:</strong> ${error.message}<br>
                    <strong>Device:</strong> ${navigator.platform}<br>
                    <strong>Browser:</strong> ${navigator.userAgent}
                `;
            }
        }

        // Initialize
        async function initialize() {
            try {
                await initWebGPU();
                await updateDeviceInfo();

                // Initialize matrix size checkboxes
                const sizesContainer = document.getElementById('sizeCheckboxes');
                sizesContainer.innerHTML = matrixSizes.map(size => `
                    <label>
                        <input type="checkbox" value="${size}" checked>
                        ${size}x${size}
                    </label>
                `).join(' ');

                // Initialize workgroup checkboxes
                const naiveWorkgroupsContainer = document.getElementById('naiveWorkgroups');
                const decoupledWorkgroupsContainer = document.getElementById('decoupledWorkgroups');

                naiveWorkgroupsContainer.innerHTML = naiveWorkgroupSizes.map(size => `
                    <label>
                        <input type="checkbox" value="${size}" ${size === '16,16' ? 'checked' : ''}>
                        ${size.replace(',', 'x')}
                    </label>
                `).join('');

                decoupledWorkgroupsContainer.innerHTML = decoupledWorkgroupSizes.map(size => `
                    <label>
                        <input type="checkbox" value="${size}" ${size === '16,16' ? 'checked' : ''}>
                        ${size.replace(',', 'x')}
                    </label>
                `).join('');

                document.getElementById('generateMatrices').addEventListener('click', async () => {
                    const selectedSizes = Array.from(document.querySelectorAll('#sizeCheckboxes input:checked'))
                        .map(cb => parseInt(cb.value));
                    await generateMatrices(selectedSizes);
                    alert('Matrices generated successfully!');
                });

                document.getElementById('runBenchmark').addEventListener('click', performBenchmark);
                document.getElementById('downloadResults').addEventListener('click', downloadResults);

            } catch (error) {
                console.error('Initialization failed:', error);
                alert('Failed to initialize WebGPU: ' + error.message);
            }
        }

        window.addEventListener('load', initialize);
    </script>
</body>
</html>
